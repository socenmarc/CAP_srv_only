'use strict';

/**
 * The module handles the processing of foreign key for managed associations.
 */

const { copyAnnotations } = require('../../model/modelUtils');
const { forEach } = require('../udict');
const { forEachManagedAssociation } = require('./utils');
const sortByAssociationDependency = require('./sortByAssociationDependency');

/**
 * Generates foreign keys and returns their names as an array
 */
function generateForeignKeys(transformers, item) {
  let arrayOfGeneratedForeignKeyNames = [];
  const { definitionName, elementName, element, parent, path } = item;
  for (let keyIndex in element.keys) {
    let key = element.keys[keyIndex];
    let keyPath = path.concat('keys', keyIndex);
    let foreignKeyElements = transformers.createForeignKeyElement(element, elementName, key, parent, definitionName, keyPath);
    if (!foreignKeyElements) continue;
    forEach(foreignKeyElements, (_name, foreignKeyElement) => {
      copyAnnotations(element, foreignKeyElement, true);
    })
    arrayOfGeneratedForeignKeyNames.push(...Object.keys(foreignKeyElements));
  }
  return arrayOfGeneratedForeignKeyNames;
}

/**
 * Expand structured keys
 * entity A {toB: association to B {stru};} -> CSN: keys:[{ref:['stru']}]
 * entity B {stru:{subid:Integer;}}
 * after expand -> keys:[{ref:['stru_subid']}]
 */
function expandStructuredKeysForElement(assoc, referenceFlattener) {
  let newKeys = [];
  for (let key of assoc.keys) {
    let paths = key.$paths;
    if (paths) {
      let lastPath = paths[paths.length - 1];
      let generatedElements = referenceFlattener.getGeneratedElementsForPath(lastPath);
      if (generatedElements) {
        generatedElements.forEach(elementName => {
          newKeys.push({ ref: [elementName], as: elementName });
        })
        continue;
      }
    }
    newKeys.push(key);
  }
  if (newKeys.length) {
    referenceFlattener.attachPaths(newKeys,assoc.keys.$path)
    assoc.keys = newKeys;
  }
}
/**
 * if a key is an association and it poins to another association,
 * the foreign keys of the target association become primary keys
 * in the current association
 */
function takeoverForeignKeysOfTargetAssociations(assoc, path, generatedForeignKeyNamesForPath, functions) {
  let newResult = [];
  for (let keyNumber in assoc.keys) {
    let key = assoc.keys[keyNumber]
    let keyPath = path.concat('keys', keyNumber);
    let resolved = functions.csnUtils.inspectRef(keyPath)
    let targetElement = resolved.art;
    if (targetElement) {
      if (functions.csnUtils.isAssociation(targetElement.type)) {
        // association key
        expandAssociationKey(key);
      } else {
        // scalar key
        newResult.push(key)
      }
    } else {
      // target element does not exist, warning is already reported, pass the key anyway
      newResult.push(key);
    }
  }

  function expandAssociationKey(key) {
    let paths = key.$paths;
    if (!paths) return;
    let lastPath = paths[paths.length - 1];
    let transitionPath = functions.referenceFlattener.getElementTransition(lastPath)
    if (transitionPath)
      lastPath = transitionPath;
    let generatedKeys = generatedForeignKeyNamesForPath[lastPath.join('/')];
    if (!generatedKeys) return;
    generatedKeys.forEach(fkName => {
      newResult.push({ ref: [fkName] });
    })
  } // expandAssociationKey

  assoc.keys = newResult;

}

function fixCardinality(assoc) {
  if (assoc.notNull) {
    if (!assoc.cardinality) {
      assoc.cardinality = {};
    }
    if (assoc.cardinality.min === undefined) {
      assoc.cardinality.min = 1;
    }
  }
}

function processSortedForeignKeys(sortedAssociations, flatKeys, functions) {

  const { csnUtils, transformers } = functions;

  // The map will collect all generated foreign key names for the specific path
  let generatedForeignKeyNamesForPath = {}; // map<path,[key-name]>

  sortedAssociations.forEach(item => {

    const { element, path } = item;

    if (csnUtils.isManagedAssociationElement(element) && element.keys) {
      if (flatKeys) takeoverForeignKeysOfTargetAssociations(element, path, generatedForeignKeyNamesForPath, functions);
      fixCardinality(element);
    }

    let arrayOfGeneratedForeignKeyNames = generateForeignKeys(transformers, item);
    generatedForeignKeyNamesForPath[item.path.join('/')] = arrayOfGeneratedForeignKeyNames;

  })

}

function expandStructuredKeys(csn, referenceFlattener) {

  forEachManagedAssociation(csn, (element) => {
    if (element.keys) {
      expandStructuredKeysForElement(element, referenceFlattener);
    }
  })

}

function processForeignKeys(csn, flatKeys, functions) {

  let { referenceFlattener, csnUtils, transformers } = functions;

  expandStructuredKeys(csn, referenceFlattener);

  // update paths and resolve references
  referenceFlattener.attachPaths(csn);
  referenceFlattener.resolveAllReferences(csn, csnUtils.inspectRef, csnUtils.isStructured);

  // sort all associations by their dependencies
  const sortedAssociations = sortByAssociationDependency(csn, referenceFlattener);

  // generate foreign keys
  processSortedForeignKeys(sortedAssociations, flatKeys, { csnUtils, transformers, referenceFlattener });
}

module.exports = processForeignKeys;
