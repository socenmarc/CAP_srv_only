const { CompileMessage, DebugCompileMessage } = require('../base/messages');
const { constructSemanticLocationFromCsnPath } = require('./location');

/**
 * @param {XSN.Model | CSN.Model} model
 * @param {any}       msg
 * @param {XSN.Location|CSN.Location|CSN.Path} location
 * @param {CSN.MessageSeverity} severity
 * @param {string}    message_id
 * @param {boolean}   useDebugMsg
 */
function buildMessage(model, msg, location, severity, message_id, useDebugMsg){
  let semanticLocation = undefined;
  if(Array.isArray(location)){
    semanticLocation = location;
    validateSemanticLocation(semanticLocation);
    location = searchForLocation(semanticLocation);
  }
  severity =  severity || msg._severity;
  return (useDebugMsg)
    ? new DebugCompileMessage(location, msg, severity, message_id, beautifySemanticLocation(semanticLocation))
    : new CompileMessage(location, msg, severity, message_id, beautifySemanticLocation(semanticLocation));

  /** @param {CSN.Path} semanticLocation */
  function searchForLocation(semanticLocation){
    let last_location = null; // Don't display a location if we cannot find one!
    /** @type {object} */
    let currentThing = model;
    for(const step of semanticLocation){
      if(!currentThing){
        return last_location;
      }
      currentThing = currentThing[step];

      if(currentThing && currentThing.$location){
        last_location = currentThing.$location;
      }
    }

    return last_location;
  }

  /** @param {CSN.Path} semanticLocation */
  function validateSemanticLocation(semanticLocation){

    if (semanticLocation.length === 0){
      throw new Error('An empty semantic location was supplied, this should not happen!');
    }

    if (semanticLocation[0] !== 'definitions'){
      throw new Error('Semantic locations must start with "definitions", found: ' + semanticLocation[0]);
    }

    if (semanticLocation.length === 1){
      throw new Error('Semantic locations must at least point to an artifact!');
    }

    return true;
  }

  /** @param {CSN.Path} csnPath */
  function beautifySemanticLocation(csnPath){
    if(!csnPath){
      return csnPath;
    }
    return constructSemanticLocationFromCsnPath(csnPath, model);
  }
}

module.exports = { buildMessage };

