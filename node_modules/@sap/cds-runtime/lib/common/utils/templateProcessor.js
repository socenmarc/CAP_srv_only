const _processElement = (processFn, row, key, elements, picked, isRoot) => {
  const _picked = picked || {}
  const plain = _picked.plain
  if (plain) {
    const element = elements[key]
    return processFn(row, key, element, plain, isRoot)
  }
  const structured = _picked.structured || {}
  for (const elName of Object.keys(structured)) {
    const subPicked = structured[elName] || {}
    // keys can potentially be created
    if (!row[key]) row[key] = {}
    const subRow = row[key]
    const subElements = elements[key].elements
    _processElement(processFn, subRow, elName, subElements, subPicked, isRoot)
    // delete empty objects
    if (!Object.keys(subRow).length) delete row[key]
  }
}

const _processRow = (processFn, row, template, tKey, tVal, isRoot) => {
  const { template: subTemplate, picked } = tVal

  _processElement(processFn, row, tKey, template.target.elements, picked, isRoot)

  // process deep
  if (subTemplate) {
    const val = row && row[tKey]
    _processComplex(processFn, val, subTemplate)
  }
}

const _processComplex = (processFn, val, template) => {
  if (Array.isArray(val)) {
    for (const subVal of val) {
      templateProcessor(processFn, subVal, template, false)
    }
  } else if (val) {
    templateProcessor(processFn, val, template, false)
  }
}

const templateProcessor = (processFn, row, template, isRoot = true) => {
  for (const [tKey, tValue] of template.elements) {
    _processRow(processFn, row, template, tKey, tValue, isRoot)
  }
}

module.exports = templateProcessor
