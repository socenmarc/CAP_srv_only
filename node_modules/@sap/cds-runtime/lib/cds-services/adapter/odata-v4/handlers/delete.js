const cds = global.cds || require('@sap/cds/lib')

const ODataRequest = require('../ODataRequest')

const {
  Components: { DATA_DELETE_HANDLER }
} = require('../okra/odata-server')

const { getSapMessages } = require('../../../../common/error/frontend')
const { validateResourcePath } = require('../utils/request')

/**
 * The handler that will be registered with odata-v4.
 * @param {Service} service
 * @param {Object} options
 * @return {Function}
 */
const del = (service, options) => {
  return async (odataReq, odataRes, next) => {
    let req
    try {
      validateResourcePath(odataReq, options, service.model)
      req = new ODataRequest(DATA_DELETE_HANDLER, service, odataReq, odataRes)
    } catch (e) {
      return next(e)
    }

    let tx
    const changeset = odataReq.getAtomicityGroupId()
    if (changeset) {
      tx = odataReq.getBatchApplicationData().txs[changeset]
    } else {
      // REVISIT: passing _as_root = true needed?
      cds.context = tx = service.tx(req, true)
    }

    let err, commit
    try {
      await tx.emit(req)

      const result = null
      if (!changeset) {
        commit = true
        await tx.commit(result)
      } else {
        // for passing into commit
        odataReq.getBatchApplicationData().results[changeset].push({ result, req })
      }
    } catch (e) {
      err = e
      if (!changeset && !commit) {
        // ignore rollback error, which should never happen
        await tx.rollback(e).catch(() => {})
      } else if (changeset) {
        // for passing into rollback
        odataReq.getBatchApplicationData().errors[changeset].push({ error: e, req })
      }
    } finally {
      req.messages && odataRes.setHeader('sap-messages', getSapMessages(req.messages, req._.req))

      if (err) next(err)
      else next(null, null)
    }
  }
}

module.exports = del
