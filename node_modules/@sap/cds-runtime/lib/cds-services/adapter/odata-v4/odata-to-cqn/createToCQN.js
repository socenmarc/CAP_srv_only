// REVISIT: should be cds.ql
const { INSERT } = require('../../../statements')

const { getFeatureNotSupportedError } = require('../../../util/errors')
const { convertUrlPathToCqn } = require('./utils')

const { ENTITY, SINGLETON, NAVIGATION_TO_ONE } = require('../okra/odata-server').uri.UriResource.ResourceKind

const UPSERT_KINDS = {
  [ENTITY]: 1,
  [SINGLETON]: 1,
  [NAVIGATION_TO_ONE]: 1
}

const _hasAllKeys = (target, data) => {
  return Object.keys(target.keys)
    .filter(k => !target.keys[k].is2one && !target.keys[k].is2many)
    .every(k => k in data)
}

/**
 * Transform odata CREATE request into a CQN object.
 *
 * @param {Object} target
 * @param {Object|Array} data
 * @param {Object} odataReq - OKRA's req
 * @param {boolean} upsert - CREATE on PUT/PATCH
 * @throw Error - if invalid segments are provided in request
 * @private
 */
const createToCQN = (target, data, odataReq, upsert) => {
  const segments = odataReq.getUriInfo().getPathSegments()
  const lastSegment = odataReq.getUriInfo().getLastSegment()

  if (lastSegment.getKind() === 'ENTITY.COLLECTION' || (upsert && UPSERT_KINDS[lastSegment.getKind()])) {
    // data does have all the keys already in case of upsert
    // if not, root has foreign key
    if (lastSegment.getKind() === NAVIGATION_TO_ONE && !_hasAllKeys(target, data)) {
      throw getFeatureNotSupportedError(`INSERT of kind "${lastSegment.getKind()} with foreign key in source entity.`)
    }
    return INSERT.into(target).entries(data)
  }

  if (lastSegment.getKind() === 'NAVIGATION.TO.MANY') {
    return INSERT.into(convertUrlPathToCqn(segments)).entries(data)
  }

  throw getFeatureNotSupportedError(`INSERT of kind "${lastSegment.getKind()}"`)
}

module.exports = createToCQN
