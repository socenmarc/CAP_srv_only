const { generateKeyPath, splitByAndGetValueByIndex, formatVal } = require('./utils')

const ODATA_COMPARATOR = {
  '=': 'eq',
  '<>': 'ne',
  '>=': 'ge',
  '<=': 'le',
  '<': 'lt',
  '>': 'gt'
}

const _between = (target, column, /* between */ lower, /* and */ upper) => {
  const ref = column.ref.join('/')
  return `(${ref} gt ${formatVal(lower.val, ref, target)} and ${ref} lt ${formatVal(upper.val, ref, target)})`
}

const _in = (target, column, /* in */ values) => {
  // values could also be subselect
  if (values.val && values.val.length) {
    const ref = column.ref.join('/')
    const expressions = values.val.map(value => `${ref} eq ${formatVal(value, ref, target)}`)
    return `(${expressions.join(' or ')})`
  }
}

const _stringifyFilter = filter => {
  return filter.reduce((str, element, i) => {
    if (i === 0) return element
    if (typeof element === 'string') {
      if (element.startsWith('(') && str.endsWith('(')) return `${str}${element}`
      if (element.startsWith(')') && str.endsWith(')')) return `${str}${element}`
    }
    return `${str} ${element}`
  }, '')
}

const _queryOptionsAsString = queryOptions => {
  const queryOptionKeys = Object.keys(queryOptions)
  if (!queryOptionKeys.length) return ''
  return `?${Object.keys(queryOptions)
    .map(key => `${key}=${queryOptions[key]}`)
    .join('&')}`
}

const _parseColumnsDeepExpand = (colRes, resExpand = []) => {
  if (Object.keys(colRes.expand).length !== 0) {
    resExpand.push('(')
    if (colRes.columns) resExpand.push(`$select=${colRes.columns};`)
    resExpand.push('$expand=')
    Object.keys(colRes.expand).forEach((key, index) => {
      resExpand.push(key)
      _parseColumnsDeepExpand(colRes.expand[key], resExpand)
      if (Object.keys(colRes.expand).length !== index + 1) resExpand.push(',')
    })
    resExpand.push(')')
  } else if (colRes.columns) resExpand.push('(', `$select=${colRes.columns}`, ')')
  return resExpand
}

const _columnsMustBeExpanded = column => {
  return column.expand.length === 0 || (column.expand.length === 1 && column.expand[[0]] === '*')
}

const _handleExpand = column => {
  const expandedElement = column.ref[0]
  if (_columnsMustBeExpanded(column)) {
    return expandedElement
  }

  const queryOptions = []
  const { select, expand } = _createSelectAndExpandStrings(column.expand)
  if (select) queryOptions.push(`$select=${select}`)
  if (expand) queryOptions.push(`$expand=${expand}`)
  return `${expandedElement}(${queryOptions.join(';')})`
}

const _createSelectAndExpandStrings = cqnColumns => {
  const columns = []
  const expands = []
  for (const column of cqnColumns) {
    if (column.func) {
      throw new Error('Feature not supported: .func in columns of SELECT statement.')
    } else if (column.expand) {
      expands.push(_handleExpand(column))
    } else if (column.ref) {
      columns.push(column.ref.join('/'))
    }
    // ignore .val in columns
  }

  return {
    select: columns.join(','),
    expand: expands.join(',')
  }
}

const _createOrderByString = orderBy => {
  return orderBy.map(o => `${o.ref.join('/')} ${o.sort}`).join(',')
}

const _createFilterString = (where, target) => /* NOSONAR */ {
  const condition = []
  for (let i = 0; i < where.length; i++) {
    const element = where[i]
    if (typeof element === 'string') {
      condition.push(ODATA_COMPARATOR[element] || element.toLowerCase())
    } else if (element.ref) {
      if (where[i + 1] === 'between') {
        condition.push(_between(target, element, where[i + 2], where[i + 4]))
        i += 4
      } else if (where[i + 1] === 'in') {
        const values = where[i + 2]
        // when sending a where clause with "col in []" we currently ignore the where clause
        // analog to interpretation for sql generation
        // double check if this is the intended behavior
        const inCondition = _in(target, element, values)
        if (inCondition) condition.push(inCondition)
        i += 2
      } else {
        condition.push(element.ref.join('/'))
      }
    } else if (element.val) {
      //
      const previousRefAsString = condition[condition.length - 2]
      condition.push(formatVal(element.val, previousRefAsString, target))
    } else if (element.func) {
      throw new Error('Feature not supported: .func in where clause of SELECT statement.')
    }
  }

  return _stringifyFilter(condition)
}

const select = (cqn, target, type) => /* NOSONAR */ {
  const url = generateKeyPath(cqn.SELECT.from, type, cqn.SELECT._transitions)
  const queryOptions = {}

  if (cqn.SELECT.groupBy) {
    throw new Error('Feature not supported: SELECT statement with .groupBy')
  }

  if (cqn.SELECT.columns) {
    const { select, expand } = _createSelectAndExpandStrings(cqn.SELECT.columns)
    if (select) queryOptions['$select'] = select
    if (expand) queryOptions['$expand'] = expand
  }

  if (cqn.SELECT.where) {
    const filter = _createFilterString(cqn.SELECT.where, target)
    if (filter) queryOptions['$filter'] = filter
  }

  if (cqn.SELECT.limit) {
    if (cqn.SELECT.limit.rows) queryOptions['$top'] = cqn.SELECT.limit.rows.val
    if (cqn.SELECT.limit.offset) queryOptions['$skip'] = cqn.SELECT.limit.offset.val
  }

  if (cqn.SELECT.orderBy) {
    queryOptions['$orderby'] = _createOrderByString(cqn.SELECT.orderBy)
  }

  if (cqn.SELECT.one) {
    queryOptions['$top'] = '1'
  }

  const queryOptionsAsString = _queryOptionsAsString(queryOptions)

  return {
    path: `${splitByAndGetValueByIndex(url.path)}${url.keys || ''}${queryOptionsAsString}`,
    method: 'GET'
  }
}

module.exports = select
