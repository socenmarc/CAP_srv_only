const cds = require('..')
module.exports = class EventHandlers {

  constructor (name, model, options={}) {
    this._handlers = { on:[], before:[], after:[], _initial:[] }
    this.name = name || new.target.name
    if (options.kind) this.kind = options.kind // shortcut
    if (model) this.model = model
    this.options = options
  }

  on     (...args) { return this._register ('on',     ...args) }
  before (...args) { return this._register ('before', ...args) }
  after  (...args) { return this._register ('after',  ...args) }

  _register (phase, event, path, handler) { //NOSONAR
    if (!handler) [ path, handler ] = [ '*', path ] // argument path is optional
    if (!handler) throw new Error ('handler must not be null')
    if (event === 'SAVE') for (let each of ['CREATE','UPDATE']) this._register (phase, each, path, handler)
    else if (is_array(event)) for (let each of event) this._register (phase, each, path, handler)
    else if (is_array(path))  for (let each of path)  this._register (phase, event, each, handler)
    else {
      // canonicalize event argument
      if (event){
        if (typeof event === 'object')
          event = event.name && /[^.]+$/.exec(event.name)[0] || _expected ({event},`a string or a CSN definition`)
        else if (event === 'SELECT') event = 'READ'
        else if (event === 'INSERT') event = 'CREATE'
        else if (event === 'each' || phase === 'after' && /^\(?each\)?/.test(handler)) {
          const h=handler; event = 'READ'
          handler = (rows,req) => is_array(rows) ? rows.forEach (r => h(r,req)) : rows && h(rows,req)
        }
      }
      // canonicalize path/entity argument
      if (path) switch (typeof path) {
        case 'object': path = path.name || _expected ({path},`a string or a CSN definition`); break
        case 'string': if (path !== '*' && !path.startsWith(this.name+'.')) path = `${this.name}.${path}`
      }
      // actually register
      this.subscribe (handler._initial ? '_initial' : phase, event, path, handler)
    }
    return this
  }

  subscribe (phase, event, path, handler) {
    this._handlers[phase].push ({ event, path, handler })
    if (phase === 'on') cds.emit('subscribe',this,event)
  }

  reject (event, path) {
    const handler = req => req.reject(405, `Event "${event}" not allowed${req.target ? ` for entity "${req.target.name}"`: ''}.`)
    handler._initial = true
    return this._register ('before', event, path, handler)
  }

  // PLEASE NOTE: This is not decided and not public yet -> do not use anywhere!
  onSucceeded (...args) { return this._on ('succeeded', ...args) }
  onFailed (...args) { return this._on ('failed', ...args) }
  _on (succeeded_or_failed, event, path, handler) {
      if (!handler) [path,handler] = [undefined,path]
      return this.before (event,path, req => req.on(succeeded_or_failed,handler))
  }

  async prepend (...impl_functions) {
    const {_handlers} = this, _new = this._handlers = { on:[], before:[], after:[], _initial:[] }
    await Promise.all (impl_functions.map (fn => is_impl(fn) && fn.call (this,this)))
    for (let each in _new) if (_new[each].length) _handlers[each] = [ ..._new[each], ..._handlers[each] ]
    this._handlers = _handlers
    return this
  }
}

const _expected = (arg,type) => cds.error(`Expected ${type} for argument '${Object.keys(arg)[0]}' but got: ${Object.values(arg)[0]}`)
const is_class = x => typeof x === 'function' && x.prototype && /^class\b/.test(x)
const is_impl = x => typeof x === 'function' && !is_class(x)
const is_array = Array.isArray
