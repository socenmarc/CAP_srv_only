/* eslint-disable no-cond-assign */
const cds = require('..'), { implicit_next } = cds.env.features
const EventHandlers = require('./Handlers')
const Transaction = require('./Transaction')

class Service extends EventHandlers {

  constructor (name, model, options={}) {
    super().name = name || new.target.name
    if (options.kind) this.kind = options.kind // shortcut
    if (model) this.model = model
    this.options = options
  }

  /** Subclasses may override this to prepare the given model */
  set model(m) { super.model = m && cds.linked(m) }

  /** Model Reflection API */
  get namespace() { return super.namespace = this.definition && this.name || this.model && this.model.namespace || !/[^\w.]/.test(this.name) && this.name }
  get definition() { return super.definition = this.model && this.model.definitions [this.name] }
  get operations() { return super.operations = _reflect (this, d => d.kind === 'action' || d.kind === 'function') }
  get entities() { return super.entities = _reflect (this, d => d.kind === 'entity') }
  get events() { return super.events = _reflect (this, d => d.kind === 'event') }
  get types() { return super.types = _reflect (this, d => !d.kind || d.kind === 'type') }

  /** Emit synchronous or asynchronous events.
   * The implementation accepts instances of cds.Event and cds.Request, as a single argument
   * or constructs a new instance of cds.Request from the given arguments.
   * @param {string|{ event?:string, path?:string, query?:CQN, data:{}, headers:{} }} event
   * @param {{}} data
   */
  emit (event, data) {
    const req = event instanceof cds.Event ? event : new cds.Request (
      typeof event === 'object' ? event : {event,data}
    )
    // if called via srv.tx(req).emit(...), this is already a tx
    if (this._is_tx) return this.dispatch(req)
    // if we have a root context from cls, we join that with a nested
    const ctx = cds.context
    if (ctx) return this.tx(ctx).dispatch(req)
    // if there's no outer tx we start a new one, which we need to commit/rollback
    const tx = this.tx(req,'_as_root')
    return tx.dispatch(req) .then (tx.commit, tx.rollback)
  }

  /** Dispatch the request through the registered event handlers
   * @param {import('./Request')} req
   */
  async dispatch (req) { //NOSONAR

    if (!req._tx) req._tx = this
    if (req._ && req._.req && !req.context) req._.req.emit ('dispatch',req) //> emit dispatch event for logging

    // Handle batches of queries
    if (is_array(req.query)) return Promise.all (req.query.map (
      q => this.dispatch ({query:q,__proto__:req})
    ))

    // REVISIT: Ensure fully-qualified entity references
    req.path

    // Prepare fetching relevant handlers
    const relevant = ({event,path}) => ( // filter to match relevant handlers
      (event  === '*' || event  === req.event) &&
      (path === '*' || path === req.entity || path === req.path)
    )

    // _initial handlers phase
    const _i = this._handlers._initial.filter (relevant)
    if (_i.length) {
      for (const each of _i) await each.handler.call (this,req)
      if (req.errors) throw _one_or_many (req.errors)
    }

    // .before handlers phase
    const b = this._handlers.before.filter (relevant)
    if (b.length) {
      await Promise.all (b.map (each => each.handler.call (this,req)))
      if (req.errors) throw _one_or_many (req.errors)
    }

    // .on handlers phase
    const o = this._handlers.on.filter (relevant)
    if (o.length) {
      const that = this; await async function next (r=req) {
        const each = o.shift(); if (!each) return //> exit unhandled
        let x = each.handler.call (that,r,next) //> we call handlers with this = tx = {__proto__:srv}
        if (is_query(x))     return r.reply (x.then ? await x : await cds.tx(r).run(x))
        if (is_promise(x))   x = await x
        if (is_defined(x))   return r.reply(x)
        if (r.results)       return r.results
        if (implicit_next)   return next()
      }()
      if (req.errors) throw _one_or_many (req.errors)
    }
    else if (req.query) throw req.reject (501, _unhandled(this,req))

    // .after handlers phase
    const a = this._handlers.after.filter (relevant)
    if (a.length) {
      await Promise.all (a.map (each => each.handler.call (this, req.results, req)))
      if (req.errors) throw _one_or_many (req.errors)
    }

    // done
    return req.results
  }

  /** Querying API */
  run (query, data) { return this.emit (data ? { query, data } : { query }) }
  insert (...args) { return INSERT(...args).bind(this) }
  create (...args) { return INSERT.into(...args).bind(this) }
  read   (...args) { return SELECT.from(...args).bind(this) }
  update (...args) { return UPDATE.entity(...args).bind(this) }
  foreach (query, data, callback) {
    if (!callback)  [ data, callback ] = [ undefined, data ]
    return this.run (query, data) .then (rows => rows.forEach(callback) || rows)
  }

  /** REST-style API */
  send   (method, path, data) { return this.emit (data ? { method, path, data } : { method, path }) }
  get    (path, data) { return is_rest(path) ? this.send('GET',   path,data) : this.read   (path, data) }
  put    (path, data) { return is_rest(path) ? this.send('PUT',   path,data) : this.update (path, data) }
  post   (path, data) { return is_rest(path) ? this.send('POST',  path,data) : this.create (path, data) }
  patch  (path, data) { return is_rest(path) ? this.send('PATCH', path,data) : this.update (path, data) }
  delete (path, data) { return is_rest(path) ? this.send('DELETE',path,data) : DELETE.from (path, data).bind(this) }

  /** Subclasses may override this to free resources */
  disconnect (tenant) { // eslint-disable-line no-unused-vars
    if (this === cds.db) cds.db = undefined
    delete cds.services[this.name]
  }
}

const is_array = Array.isArray
const is_query = x => x && (x.SELECT || x.INSERT || x.UPDATE || x.DELETE)
const is_promise = x => x && x.then
const is_defined = x => x !== undefined
const is_rest = x => x && typeof x === 'string' && x[0] === '/'

const _reflect = (srv,filter) => !srv.model ? [] : srv.model.childrenOf (srv.namespace,filter)
const _one_or_many = (errors) => {
  const e = errors.length === 1 ? errors[0] : { message: 'MULTIPLE_ERRORS', details: errors }
  if (!e.stack) e.stack = 'not available' // REVISIT: OKRA expects a stack
  return e
}
const _unhandled = ({name:s},{event:e,path:p}) => `Service "${s}" has no handler for "${e}${p?' '+p:''}".`

Service._is_service_class = Service.prototype._is_service_instance = true //> for factory
Service.prototype.transaction = Transaction.srv_tx // @deprecated legacy alias for srv.tx
Service.prototype.tx = Transaction.srv_tx
module.exports = Service
