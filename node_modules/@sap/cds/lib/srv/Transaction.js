const cds = require('../index'), DEBUG = cds.debug('tx')
const { Context } = cds.Request
const _context = Symbol()

class Transaction {

  /**
   * Constructs a new Transaction as a derivate of `srv` (i.e. {__proto__:srv})
   * @returns { Transaction & import('./Service') }
   */
  static srv_tx (req,_as_root) { const srv = this
    if (srv._is_tx) return srv
    if (!req) {
      // called as srv.tx() -> new root transaction
      return RootTransaction.for (srv, new Context)
    }
    if (req instanceof Context) {
      // REVISIT: temporal compatibility to fragile tx handlings in rest client
      if (!_as_root) return NestedTransaction.for (srv, req.context || req)
      // called on a nested req -> nested tx
      if (req.context) return NestedTransaction.for (srv, req.context)
      // called on a req with a root tx -> nested tx
      if (req._tx) return NestedTransaction.for (srv, req)
      // called on a top-level req -> root tx
      else return req._tx = RootTransaction.for (srv, req)
    }
    if (req[_context]) {
      // again called with an arbitrary object -> see below
      return NestedTransaction.for (srv, req[_context])
    } else {
      // called with an arbitrary object
      const root = new Context(req)
      Object.defineProperty(req,_context,{value:root})
      return RootTransaction.for (srv, root)
    }
  }

  static for (srv,root) {
    const txs = root.transactions || (root.transactions = new Map)
    let tx = txs.get(srv)
    if (!tx) {
      txs.set (srv, tx = new this (srv,root)) // NOSONAR
      tx.context = root
      tx._is_tx = true
      tx._state = 'new' // REVISIT: compat for continue with tx
      if ('begin' in srv) { // queue all further ops behind an initial .begin()
        const ready = tx.begin()
        tx.dispatch = async (req) => {
          // REVISIT: ready = tx.begin() -> promise must be awaited -> this._busy === true if commit/rollback w/o any runs (cf. cds-runtime/lib/db/Service.js)
          // REVISIT: move to first non.read db interaction?
          await ready
          delete tx.dispatch
          return tx.dispatch (req)
        }
      }
    }
    return tx
  }

  constructor(srv) {
    return Object.create(srv)
  }
}

class RootTransaction extends Transaction {

  constructor (srv) {
    const tx = super(srv), proto = new.target.prototype
    tx.commit = proto.commit.bind(tx)
    tx.rollback = proto.rollback.bind(tx)
    return tx
  }

  async commit (res) {
    try {
      if (this.__proto__.commit) await this.__proto__.commit.call(this,res)
      await this.context.emit('succeeded',res)
    } catch(err) {
      await this.rollback(err)
    }
    await this.context.emit('done')
    return res
  }

  async rollback (err) {
    try { // eslint-disable-next-line no-console
      DEBUG && console.trace (
        `\n--------------------------------------------------------\n`,
        `ROLLBACK due to:\n`, err,
        `\n--------------------------------------------------------\n`,
      )
      if (this.__proto__.rollback) await this.__proto__.rollback.call(this,err)
      await this.context.emit('failed',err)
    } finally {
      await this.context.emit('done')
    }
    if (err) throw err
  }
}


class NestedTransaction extends Transaction {

  constructor (srv,root) {
    const tx = super(srv), proto = new.target.prototype
    tx.commit = 'commit' in srv ? proto.commit.bind(tx) : _no_commit
    tx.rollback = 'rollback' in srv ? proto.rollback.bind(tx) : _no_rollback
    root.prependOnceListener ('succeeded', ()=>tx.commit())
    root.prependOnceListener ('failed', ()=>tx.rollback())
    if ('end' in srv) root.once ('done', ()=> srv.end())
    return tx
  }

  async commit (res) {
    if (this.__proto__.commit) await this.__proto__.commit.call(this,res)
    return res
  }

  async rollback (err) {
    if (this.__proto__.rollback) await this.__proto__.rollback.call(this,err)
    if (err) throw err
  }

}


const _no_commit = (x)=>{ return x }
const _no_rollback = (e)=>{ if (e) throw e }
module.exports = Transaction
