const cds = require ('../index'), {snapi} = cds.env.features


async function cds_load (files, options) {
  const all = cds.resolve(files,options) || cds.error (
    `Couldn't find a CDS model for '${files}' in ${process.cwd()}`,
    { code:'MODEL_NOT_FOUND', files }
  )
  return this.get (all,options,'inferred')
}

async function cds_get (files, options, _inferred) { // NOSONAR

  const o = typeof options === 'string' ? { flavor:options } : options || {}
  if (!files) files = ['*']; else if (!Array.isArray(files)) files = [files]
  if (o.files || o.flavor === 'files') return cds.resolve(files,o)
  if (o.sources || o.flavor === 'sources') return _sources4 (cds.resolve(files,o))

  const csn = await this.compile.to.csn (files,o,
    o.parse  ? 'parsed' :
    o.plain  ? 'xtended' :
    o.clean  ? 'xtended' : // for compatibility
    o.flavor || _inferred || 'parsed'
  )
  if (o.min)  require('../alpha/_skip_unused') (csn)
  if (snapi && csn.messages) delete csn.messages

  cds.emit ('loaded', csn)
  return csn
}


const _sources4 = async (files) => {
  const {path:{relative},fs:{promises:{readFile}}} = cds.utils, cwd = process.cwd()
  const sources = await Promise.all (files.map (f => readFile(f,'utf-8')))
  return files.reduce ((all,f,i) => { all[relative(cwd,f)] = sources[i]; return all },{})
}

module.exports = Object.assign (cds_get, { inferred: cds_load })
