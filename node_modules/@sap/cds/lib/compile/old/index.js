const cdsv = require('./cdsv')
const cds = require('../..')
const _skip_unused = require ('../../alpha/_skip_unused')

module.exports = (compile) => {
  compile.to = {__proto__:compile.to,

    csn: (m,o) => {
      if (Array.isArray(m)) {
        const files = cds.resolve(m) || cds.error (
          `Couldn't find a CDS model for '${m}' in ${process.cwd()}`,
          { code:'MODEL_NOT_FOUND', model:m }
        )
        return cdsv.compile(files,undefined,o)
      } else {
        return cdsv.parse(m,o)
      }
    },
    cdl: (csn,o) => _2many (cdsv.toCdl(csn,o),'.cds'),
    sql: _2sql,

    hdbcds: _2hdbcds,
    hdbtable: (csn,o) => { _skip_unused (csn); return _2manyMap (cdsv.toHdi (csn, o))},

    edm: (csn,o) => _2edm (csn,o, 'metadata_json'),
    edmx: (csn,o) => _2edm (csn,o, {off: 'metadata', only: 'annotations'}[o && o.annos]),
    annos: (csn,o) => _2edm (csn,o, 'annotations'),
    swgr: (csn,o) => _2many (cdsv.toSwagger(csn,o).services, '.swgr.json'),

  }
  return compile
}



/** Return output of 2hana as an iterable */
function* _2many (content, suffix='.hdbcds') {
  for (let each in content) yield [content[each], // content
    { name: each.replace(/[.:/\\]/g, '_'), suffix }
  ]
}

/** Return output of e.g. 2hdi for hdbtable/hdbview as an iterable */
function* _2manyMap(content) {
  for (const suffix of Object.keys(content)) {
    if (suffix !== 'messages') {
      const ext = '.' + suffix
      const artifacts = content[suffix]
      for (const name of Object.keys(artifacts)) {
        yield [artifacts[name], { name, suffix: ext }]
      }
    }
  }
}


function _2sql (csn,o={}) {
  if (cds.env.features.skip_unused)  _skip_unused (csn)
  const all=[], {sql} = cdsv.toSql (csn,o)
  for (let e in sql)  all.push (sql[e].replace(/-- generated by.*\n/,'').replace(/;$/, ''))
  if (cds.env.features.localized) {
    (_2sql.unfold_ddl || (_2sql.unfold_ddl = require ('../../alpha/_localized').unfold_ddl)) (all, csn, o)
  }
  // return output as array of ddl statements or a concatenated string of which:
  if (o && o.as === 'str') return '\n'+ all.join(';\n\n') +';\n'
  else return all
}

function _2hdbcds (csn,o={}) {
  _skip_unused (csn)
  return _2many (cdsv.toHana(csn,o).hdbcds, '.hdbcds')
}

/** Returns output of 2edm/x as a single json object or edmx string or as an iterable for all of which */
function _2edm (csn, o={}, what='combined') { // NOSONAR

  if (what === 'combined')  o.combined = true;  else o.separate = true
  if (what === 'metadata_json')  o.json = true;  else o.xml = true
  if (!o.version)  o.version = o.json ? 'v4' : cds.env.odata.version

  const {services} = cdsv.toOdata(csn,o) || {}
  const chosen = o.service

  if (chosen === 'all') { //> all services
    const all = function*(){ for (let s in services)  yield [ _result(s), {name:s} ] }
    return all()
  } else if (chosen) { //> a specific service
    const one = Object.keys(services).find (n => n.indexOf(chosen) >= 0)
    return one ? _result(one) : _not_found (chosen)
  } else { //> a single service
    const [one,many] = Object.keys(services)
    return many ? _choose_one_of(services) : _result(one)
  }

  function _result (name) {
    if (Object.keys(services).length === 0)  throw new Error('No service definitions found')
    const x = services[name][what]
    return o.as === 'str' && typeof x !== 'string' ? JSON.stringify(x) : x
  }
  function _choose_one_of (all) {
    throw new Error (`[cds] - multiple service definitions found in model; add one of...\n
    -s all ${Object.keys(all).map (each => `\n    -s ${each}`).join('')} \n`)
  }
  function _not_found (name) {
    if (Object.keys(services).length === 0)  throw new Error('No service definitions found')
    throw new Error (`[cds] - no service definition matching '${name}' found among...
    ${Object.keys(services).map (each => `\n   ${each}`).join('')} \n`)
  }

}
