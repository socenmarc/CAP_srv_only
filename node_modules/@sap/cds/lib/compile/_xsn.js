const cdsc = require ('@sap/cds-compiler')
const cds = require ('../index')


function cds_compile_to_xsn (model, options, _flavor) {

  // check arguments
  if (!model) throw new Error(`Argument 'model' must be one of:
    - a CDL source string,
    - a CDS model in XSN or CSN format, or
    - a dictionary of CDS sources
    - an array of paths, filenames, or '*'`
  )
  if (_is_xsn(model)) return model

  // prepare options
  const o = _options4 (options, _flavor)
  const _xsn = (xsn) => {
    xsn.meta.flavor = o.flavor || 'inferred'
    return xsn
  }

  // call compiler and return xsn...
  if (Array.isArray(model)) {
    // load and compile files -> async
    const files = cds.resolve (model) || cds.error (
      `Couldn't find a CDS model for '${model}' in ${process.cwd()}`,
      { code:'MODEL_NOT_FOUND', model }
    )
    return cdsc.compile(files,o.cwd,o) .then (_xsn)
  } else {
    // compile in-memory sources -> sync
    return _xsn (cdsc.compileSources(model,o))
  }
}


const _is_xsn = (x) => (x.definitions || x.extensions) && x.$builtins
const _flavors = {
  'parsed':   { level:1, cdsc_options: { parseCdl:true } },
  'xtended':  { level:2, cdsc_options: { toCsn:{flavor:'gensrc'} } },
  'inferred': { level:3 },
}
const _flavor4 = (o) => {
  const flavor = typeof o === 'string' ? o : o && o.flavor || 'inferred'
  if (flavor in _flavors) return flavor; else throw new Error (
    `Option 'flavor' is expected to be one of [ ${Object.keys(_flavors)} ]; got: '${flavor}'`
  )
}
const _options4 = (options, _flavor) => {
  const flavor = _flavor ? _flavor4(_flavor) : _flavor4(options)
  const spec = _flavors[flavor]
  const o = { ...options, flavor, ...spec.cdsc_options, ...cds.env.cdsc }
  const names = o.names || o.sql_mapping || cds.env.sql.names
  if (names !== 'plain') o.sqlMapping = names
  if (o.docs) o.docComment = true
  if (o.locations) o.withLocations = true
  return o
}

module.exports = Object.assign (cds_compile_to_xsn, { _flavor4 })
