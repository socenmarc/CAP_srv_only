const fs = require ('./fs')

const SEPARATOR = /[,;\t]/
const CSV = module.exports = { read, parse, readHeader, stripComments, serialize }

function read (res) {
  try{
    return CSV.parse (fs.readFileSync (res, 'utf-8'))
  } catch(e){/* ignore */}
}

function parse (csv) {
  if (csv[0] === BOM)  csv = csv.slice(1)
  let sep
  const lines = csv.split(/\s*\n/)
  const rows = [], headers = []
  for (let line of lines) {
    if (!rows.length && _ignoreLine (line))  continue
    if (!sep)  [sep] = SEPARATOR.exec(line)||[';']
    const values=[]; let val, currCol=0, c, inString=false
    for (let i=0; i<line.length; ) {
      c = line[i++]
      if (c === sep && !inString) {  // separator
        currCol++
        if (!rows.length && val !== undefined)  headers.push (currCol)     // skip column if header value is empty
        if (headers.includes(currCol))  values.push (_value4(val)) // skip value if column was skipped
        val = undefined //> start new val
      }
      else if (c === '"' && val === undefined) { // start quoted string
        val = ''
        inString = true
      }
      else if (c === '"' && inString) { // within quoted string
        if (line[i] === '"')  val += line[i++]  // escape quote:  "" > "
        else inString = false // stop string
      }
      else {  // normal char
        if (val === undefined)  val = ''
        val += c === '\\' ? '\\\\' : c
      }
    }
    // remaining value
    currCol++
    if (!rows.length && val !== undefined)  headers.push(currCol)  // skip column if header value is empty
    if ((val !== undefined || c === sep) && headers.includes(currCol))  values.push (_value4(val))
    if (values.length > 0)  rows.push (values)
  }
  return rows
}

function serialize (rows, columns, bom='\ufeff') {
  let csv = bom + ( columns || Object.keys(rows[0]) ).join(';') +"\n"
  for (let key in rows)  csv += `${key};${rows[key]}\r\n`
  return csv
}

async function readHeader (inStream, o={ignoreComments:true}) {
  let delimiter = ';'
  let cols = []
  await _filterLines (inStream, null, line => {
    if (!cols.length) {
      if (o.ignoreComments && _ignoreLine(line))  return false;
      [delimiter] = SEPARATOR.exec(line)||[';']
      cols = line.split(delimiter) .map (each => each.trim()) .filter(each=>each.length)
    }
    return true
  })
  return {cols, delimiter}
}

async function stripComments(inStream, outStream) {
  let prelude = true
  await _filterLines (inStream, outStream, line => {
    if (prelude) {
      if (_ignoreLine(line))  return false
      prelude = false
    }
    return true
  })
}

function _value4 (val) { //NOSONAR
  if (val)  val = val.trim()
  if (val === 'true') return true
  if (val === 'false') return false
  else return val
}

function _ignoreLine(line) {
  return line[0] === '#' || !line.trim().length
}

function _filterLines (input, out, filter) {
  return new Promise((resolve, reject)=> {
    const rl = require('readline').createInterface({input, crlfDelay: Infinity})
    let filtered = false
    rl.on ('line', line => {
      if (filter (line))
        if (out)  out.write (line+'\n')
      else
        filtered |= true
    })
    rl.on ('close', ()  => {
      if (out)  out.end()
      resolve(filtered)
    })
    rl.on ('error', err => reject(err))
  })
}

const BOM = '\ufeff'
