/**
 * Flatten a two dimensional array into a one dimensional array
 * @param arr The array to be flattened.
 * @returns A one dimensional array.
 */
export declare function flat<T>(arr: T[][]): T[];
/**
 * Remove all duplicates from array
 * @param arr - Array that might contain duplicates
 * @returns Array of unique items
 */
export declare function unique<T>(arr: T[]): T[];
/**
 * Get the last item from an array. Returns undefined if the array is empty.
 * @param arr - Array to get the last item of
 * @returns Last item of the array or undefined if the array was empty
 */
export declare function last<T>(arr: T[]): T | undefined;
/**
 * Get the first item from an array. Returns undefined if the array is empty.
 * @param arr - Array to get the first item of
 * @returns Fist item of the array or undefined if the array was empty
 */
export declare function first<T>(arr: T[]): T | undefined;
/**
 * Split the given array in chunks
 * @param arr - Array to be splitted. The last aray could be shorter.
 * @param chunkSize - Size of the chunks
 * @returns Array with arrays of chunks size.
 */
export declare function splitInChunks<T>(arr: T[], chunkSize: number): T[][];
/**
 * We want to provide methods which accept a variable single number of elements and arrays.
 * The overloaded signature to achieve this is:
 * function doSomething(array: T[])
 * function doSomething(...varArgs: T[])
 * functiondoSomething(first: undefined | T | T[], ...rest: T[]) {
 *   //implementation
 * }
 * This wrapper methods makes it easy build an array from the input.
 * @param firstOrArray - Either an array, the first element of the var args or undefined if no argument was given.
 * @param rest - Second to last element if var args were used, empty array if the frist argument is an array.
 * @returns Array from the input or empty array if no input was given.
 */
export declare function variadicArgumentToArray<T>(firstOrArray: undefined | T | T[], rest: T[]): T[];
//# sourceMappingURL=array.d.ts.map