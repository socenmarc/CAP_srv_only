"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.flatten = exports.assoc = exports.pick = exports.renameKeys = exports.mergeSome = exports.assocSome = exports.propertyExists = void 0;
/**
 * Checks if a chain of properties exists on the given object.
 *
 * @param obj - The object to be checked.
 * @param properties - Chained properties.
 * @returns True if the property chain leads to a truthy value, false otherwise.
 */
function propertyExists(obj) {
    var properties = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    if (!properties.length) {
        return true;
    }
    if (obj && obj.hasOwnProperty(properties[0])) {
        return propertyExists.apply(void 0, __spreadArrays([obj[properties[0]]], properties.slice(1)));
    }
    return false;
}
exports.propertyExists = propertyExists;
/**
 * Adds the value to the object if it is neither null nor undefined.
 * Note that this is different to JS idiomatic checks for truthy/falsy values, i.e. an empty string will result in key/value pairs beeing added.
 *
 * @deprecated This will be removed in version 2.0 of the SDK.
 *
 * @param key - The key to associate with the given value.
 * @param value - The value to associate with the given key.
 * @param obj - The object on which to create the association.
 * @returns A copy of the input object with the new key-value pair if the value is neither null nor undefined.
 */
exports.assocSome = function (key, value) { return function (obj) {
    if (typeof value !== 'undefined' && value !== null) {
        return exports.assoc(key, value, obj);
    }
    return __assign({}, obj);
}; };
/**
 * Merges the two object if second object is neither null nor undefined.
 * If a key exists on a and b the value from b is taken
 *
 * @deprecated This will be removed in version 2.0 of the SDK.
 *
 * @param a - The object to merge into.
 * @param b - The object which to merge into a.
 * @returns A copy of the merge(a, b) or a if b is undefined or null.
 */
exports.mergeSome = function (a, b) {
    if (typeof b !== 'undefined' && b !== null) {
        return __assign(__assign({}, a), b);
    }
    return a;
};
/**
 * Takes an object and returns a new object whose keys are renamed according to the provided key mapping.
 * Any keys in the input object not present in the key mapping will be present in the output object as-is.
 * If a key in the key mapping is not present in the input object, the output object will contain the key with value "undefined".
 *
 * @param keyMapping - An object mapping keys of the input object to keys of the output object.
 * @param obj - The input object.
 * @returns An object with renamed keys.
 */
exports.renameKeys = function (keyMapping, obj) {
    var unchangedEntries = Object.keys(obj)
        .filter(function (k) { return !Object.keys(keyMapping).includes(k); })
        .reduce(function (newObj, key) {
        var _a;
        return (__assign(__assign({}, newObj), (_a = {}, _a[key] = obj[key], _a)));
    }, {});
    return Object.entries(keyMapping).reduce(function (newObj, _a) {
        var _b;
        var oldKey = _a[0], newKey = _a[1];
        return (__assign(__assign({}, newObj), (_b = {}, _b[newKey] = obj[oldKey], _b)));
    }, unchangedEntries);
};
/**
 * Selects  properties of an objects and returns a shallow copy.
 * Non existing keys in the source object are ignored.
 *
 * @param keys - properties to be selected
 * @param obj - object from which the values are taken
 * @returns an object with the selected keys and corresponding values.
 */
exports.pick = function (keys, obj) {
    var result = {};
    keys.forEach(function (key) {
        var value = obj[key];
        if (Object.keys(obj).includes(key)) {
            result[key] = value;
        }
    });
    return result;
};
/**
 * Adds a key value pair to the given objects and returns a shallow copy.
 * If the key is already present it will be overwritten.
 *
 * @param key - key to be added
 * @param value - value to be added
 * @param obj - object the key value pair is added to.
 * @returns the object with the key value pair added
 */
exports.assoc = function (key, value, obj) {
    var _a;
    return (__assign(__assign({}, obj), (_a = {}, _a[key] = value, _a)));
};
/**
 * Flattens a array: [1,[2,[3,4]],5] will become [1,2,3,4,5].
 * Non primitive values are copied by reference.
 *
 * @param input - array to be flattened
 * @returns the flat array.
 */
exports.flatten = function (input) {
    var flatResult = [];
    var stack = __spreadArrays(input);
    while (stack.length > 0) {
        var current = stack.pop();
        if (!Array.isArray(current)) {
            flatResult.push(current);
        }
        else {
            stack.push.apply(stack, current);
        }
    }
    return flatResult.reverse();
};
//# sourceMappingURL=object.js.map