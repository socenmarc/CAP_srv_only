"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.variadicArgumentToArray = exports.splitInChunks = exports.first = exports.last = exports.unique = exports.flat = void 0;
/**
 * Flatten a two dimensional array into a one dimensional array
 * @param arr The array to be flattened.
 * @returns A one dimensional array.
 */
function flat(arr) {
    return arr.reduce(function (flattened, subArr) { return __spreadArrays(flattened, subArr); }, []);
}
exports.flat = flat;
/**
 * Remove all duplicates from array
 * @param arr - Array that might contain duplicates
 * @returns Array of unique items
 */
function unique(arr) {
    return Array.from(new Set(arr));
}
exports.unique = unique;
/**
 * Get the last item from an array. Returns undefined if the array is empty.
 * @param arr - Array to get the last item of
 * @returns Last item of the array or undefined if the array was empty
 */
function last(arr) {
    return arr.length ? arr[arr.length - 1] : undefined;
}
exports.last = last;
/**
 * Get the first item from an array. Returns undefined if the array is empty.
 * @param arr - Array to get the first item of
 * @returns Fist item of the array or undefined if the array was empty
 */
function first(arr) {
    return arr[0];
}
exports.first = first;
/**
 * Split the given array in chunks
 * @param arr - Array to be splitted. The last aray could be shorter.
 * @param chunkSize - Size of the chunks
 * @returns Array with arrays of chunks size.
 */
function splitInChunks(arr, chunkSize) {
    var result = [];
    if (arr) {
        for (var i = 0; i < arr.length; i += chunkSize) {
            result = __spreadArrays(result, [arr.slice(i, i + chunkSize)]);
        }
    }
    return result;
}
exports.splitInChunks = splitInChunks;
/**
 * We want to provide methods which accept a variable single number of elements and arrays.
 * The overloaded signature to achieve this is:
 * function doSomething(array: T[])
 * function doSomething(...varArgs: T[])
 * functiondoSomething(first: undefined | T | T[], ...rest: T[]) {
 *   //implementation
 * }
 * This wrapper methods makes it easy build an array from the input.
 * @param firstOrArray - Either an array, the first element of the var args or undefined if no argument was given.
 * @param rest - Second to last element if var args were used, empty array if the frist argument is an array.
 * @returns Array from the input or empty array if no input was given.
 */
function variadicArgumentToArray(firstOrArray, rest) {
    if (Array.isArray(firstOrArray)) {
        return __spreadArrays(firstOrArray, rest);
    }
    return firstOrArray ? __spreadArrays([firstOrArray], rest) : __spreadArrays(rest);
}
exports.variadicArgumentToArray = variadicArgumentToArray;
//# sourceMappingURL=array.js.map