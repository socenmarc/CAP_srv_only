'use strict';

const has = Object.prototype.hasOwnProperty;
const { checkArtifactHasProperType } = require('./checkArtifacts');
const { isComposition } = require('../model/modelUtils.js')
const { makeMessageFunction } = require('../base/messages');

/**
 * Run primary key checks on the given element, for example type checks.
 */
function checkPrimaryKey(elem, model) {
  const { error, message } = makeMessageFunction(model);
  let type = '';
  // apparently this is the resolved type (over an derived type chain)
  if(elem._finalType && elem._finalType.type && elem._finalType.type._artifact)
    type = elem._finalType.type._artifact.name.absolute;

  /**
   * Check that a primary key element is not an unmanaged association or contains unmanaged associations
   *
   * @param {any} element Element to check recursively
   */
  function checkForUnmanagedAssociations(element){
    if(element.onCond) {
      message('unmanaged-as-key', [ elem.key.location, elem ], {}, 'Unmanaged associations cannot be used as primary key', ['Error']);
    }

      // Recursively check sub-elements for structured types
    if(element.elements){
      for(let elemName of Object.keys(element.elements)){
        const subElement = element.elements[elemName];
        checkForUnmanagedAssociations(subElement);
      }
    }
  }

  /**
   * Check that a primary key element is not array-like or contains array-like elements
   *
   * @param {any} element Element to check recursively
   */
  function checkKeyArrayLike(element){
    if(element.items){
      error(null, [ element.location, element ], {}, 'Array-like types cannot be used as primary key');
    }

    // Recursively check sub-elements for structured types
    if(element.elements){
      for(let elemName of Object.keys(element.elements)){
        const subElement = element.elements[elemName];
        checkKeyArrayLike(subElement);
      }
    }
  }

  if(elem.key && elem.key.val === true){
    if(['cds.hana.ST_POINT', 'cds.hana.ST_GEOMETRY'].includes(type)){
      error(null, [ elem.location, elem ], { type }, 'Type $(TYPE) cannot be used as primary key');
    }

    checkForUnmanagedAssociations(elem);
    checkKeyArrayLike(elem);
  }
}

/**
 * Non-recursive check if sub-elements have a "localized" keyword since this is
 * not yet supported.
 *
 * This check is not recursive to avoid a runtime overhead. Because of this it fails
 * to detect scenarios with indirections, e.g.
 *
 *   type L : localized String;
 *   type L1 : L;
 *   type L2 : L1;
 *
 *   entity E {
 *     struct : {
 *       subElement : L2;
 *     }
 *   }
 *
 * @param {XSN.Artifact} element
 * @param {XSN.Model} model
 */
function checkLocalizedSubElement(element, model) {
  // TODO: Recursive check
  function hasTypeLocalizedElements(type) {
    if (!type)
      return false;
    for (const elementName in type.elements) {
      const element = type.elements[elementName];
      if (element.localized && element.localized.val === true)
        return true;
      if (isTypeLocalized(element.type))
        return true;
    }
    return false;
  }

  // TODO: Recursive check
  function isTypeLocalized(type) {
    return (type && type._artifact && type._artifact.localized &&
            type._artifact.localized.val === true);
  }

  const { warning } = makeMessageFunction(model);
  const isSubElement = element._parent && element._parent.kind === 'element';

  if (element.localized && element.localized.val === true && isSubElement) {
    warning('localized-sub-element', [ element.localized.location, element ], {},
            'Keyword "localized" is ignored for sub elements');
    return;
  }

  if (!element.type)
    return;

  if ((isTypeLocalized(element.type) && isSubElement) || hasTypeLocalizedElements(element._finalType)) {
    warning('localized-sub-element', [ element.type.location, element ], { type: element.type },
            'Keyword "localized" in type $(TYPE) is ignored for sub elements');
  }
}

// Perform checks for element (or type) 'elem' concerning managed associations,
// only for managed assocs directly declared on 'elem', not those from derived
// types etc (checked there): If no explicit foreign keys are provided, there
// must be at least one implicit one (i.e. the target must have keys).
// Cardinality of a managed association should not be to-many, except for partial keys.
function checkManagedAssoc(elem, model) {
  const { error, warning } = makeMessageFunction(model);
  const target = elem.target;
  // Not a managed assoc at all, inferred elem or redirected => nothing to check
  if (!target || !target._artifact || elem.on || elem.onCond || elem.$inferred || !elem.type || elem.type.$inferred || !['entity', 'view'].includes(target._artifact.kind) || target._artifact.abstract && target._artifact.abstract.val) {
    return;
  }
  // No foreign keys at all => error
  const foreignKeys = elem.foreignKeys;
  if (!foreignKeys) {
    error(null, target.location, `The target "${target._artifact.name.absolute}" of the managed association "${elem.name.id}" does not have keys`);
  }
  const targetMax = (elem.cardinality && elem.cardinality.targetMax && elem.cardinality.targetMax.val);
  if (targetMax === '*' || Number(targetMax) > 1) {
    if(doForeignKeysCoverTargetKeys(foreignKeys,target._artifact.elements)) {
      // FIXME: convenience function (reuse in forHana)?
      const isNoDb = elem._parent.abstract || ((elem._parent['@cds.persistence.skip'] && elem._parent['@cds.persistence.skip'].val !== null && elem._parent['@cds.persistence.skip'].val !== false)|| (elem._parent['@cds.persistence.exists'] && elem._parent['@cds.persistence.exists'].val !== null && elem._parent['@cds.persistence.exists'].val !== false));
      let assocType = isComposition(elem.type) ? 'composition' : 'association';
      warning(isNoDb ? 'to-many-no-on-noDB' : 'to-many-no-on', elem.cardinality.location || elem.name.location, {},
              `The ${assocType} "${elem.name.id}" has cardinality "to many" but no ON-condition`);
    }
  }
}

// checks if the foreign keys cover completely the target keys
function doForeignKeysCoverTargetKeys(foreignKeys,targetElements) {
  let keysOfTarget = collectKeys(targetElements)
  let flattenedFKs = [];
  // flatten foreign keys into flattenedFKs
  for(let name in foreignKeys) {
    let fk = foreignKeys[name];
    let fullKeyName = fk.targetElement.path.map(X => X.id).join('.')
    let hasChildren=false;
    keysOfTarget.forEach(K => {
      if(K.startsWith(fullKeyName+'.')) { // structured key found
        hasChildren=true;
        flattenedFKs.push(K);
      }
    })
    if(!hasChildren)
      flattenedFKs.push(fullKeyName);
  }
  // check keysOfTarget are included into flattenedFKs
  let allKeysCovered=true;
  keysOfTarget.forEach(K => {
    if(!flattenedFKs.includes(K))
      allKeysCovered=false;
  })
  return allKeysCovered;

  // function walks elements recursively and returns all keys, structured ones are joined with a dot
  function collectKeys(elements,parent=[],insideKey=false) {
    let keys=[]
    if(!elements) return keys;
    for(let elementName in elements) {
      let element = elements[elementName];
      let tkey = element.key;
      let isKey=false;
      if(tkey && tkey.val || insideKey) {
        if(!element.elements)
          keys.push(parent.concat(elementName).join('.'))
        isKey=true;
      }
      keys.push(...collectKeys(element.elements,parent.concat(elementName), isKey));
    }
    return keys;
  }
}

// Check element 'elem' for semantical errors involving virtual elements
function checkVirtualElement(elem, model) {
  const { error } = makeMessageFunction(model);
  // when the element itself is declared as virtual
  if (elem.virtual) {
    if (elem.key && elem.key.val) {
      error(null, elem.location, `Element cannot be virtual and key`);
    }
    if (isStruct(elem)) {
      error(null, elem.location, `Element cannot be virtual and structured`);
    }
    if (isAssoc(elem)) {
      error(null, elem.location, `Element cannot be virtual and an association`);
    }
  }
  if(isAssoc(elem))
    checkAssociation(elem, model);
}

// Check that a structured element ist not casted to a different type
function checkStructureCasting(elem, model) {
  if (elem.type && !elem.type.$inferred) {
    const { error } = makeMessageFunction( model );
    const loc = elem.type.location || elem.location;

    if (elem._finalType && elem._finalType.elements)
      error('type-cast-structured', [ loc, elem ], {}, `Cannot cast to structured element`);

    else if (elem.value && elem.value._artifact && elem.value._artifact._finalType && elem.value._artifact._finalType.elements)
      error('type-cast-structured', [ loc, elem ], {}, `Structured element cannot be casted to a different type`);
  }
  if (elem.value && elem.value.args) {
    elem.value.args.forEach(arg => checkStructureCasting(arg, model));
  }
}

function checkAssociation(elem, model) {
  const { error } = makeMessageFunction(model);
  // when virtual element is part of association
  if (elem.foreignKeys) {
    for (let k in elem.foreignKeys) {
      let key = elem.foreignKeys[k].targetElement;
      if (key && key._artifact && key._artifact.virtual && key._artifact.virtual.val === true) {
        error(null, key.location, `Virtual elements cannot be used as a foreign key for a managed association`);
      }
    }
  }
  if (elem.onCond && !elem.onCond.$inferred)
    checkAssociationCondition(elem, model, elem.onCond);
}

function checkAssociationCondition(elem, model, onCond) {
  if(onCond===undefined)
    return;
  if(Array.isArray(onCond)) // condition in brackets results an array
    onCond.forEach(Cond => checkAssociationCondition(elem, model, Cond))
  else
    checkAssociationConditionArgs(elem, model, onCond.args, onCond.op)
}

function checkAssociationConditionArgs(elem, model, args, op) {
  if(!args)
    return;
  args.forEach(Arg => checkAssociationOnCondArg(elem, model, Arg, op));
}

function checkAssociationOnCondArg(elem, model, arg, op) {
  if(Array.isArray(arg)) {
    arg.forEach(Arg => checkAssociationOnCondArg(elem, model, Arg, op))
    return;
  } else {
    checkAssociationConditionArgs(elem, model, arg.args, arg.op);
  }

  singleCheckUnmanagedAssocCondArgumentNoFollowUnmanagedAssoc(elem, model, arg, op);
}

function singleCheckUnmanagedAssocCondArgumentNoFollowUnmanagedAssoc(elem, model, arg, op) {
  if(!arg.path)
    return;
  let path0=arg.path[0]
  if(!path0)
    return;
  if(path0.id=='$self') { // $self (backlink) checks
    checkAssociationArgumentStartingWithSelf();
    return;
  }
  if(!path0._artifact) // not resolved
    return;
  let artifactName = path0._artifact.name;
  if(artifactName.absolute && artifactName.element) {
    let targetArtifact = model.definitions[artifactName.absolute];
    if (targetArtifact instanceof Array) {
      return;
    }
    let argTarget = targetArtifact.elements[artifactName.element];
    //the check is valid for unmanaged associations
    //TODO clarify if the full resolved path to the target field should consist of managed associations or just the first
    if(isUnmanagedAssociation(argTarget)) {
      var same = path0.id === elem.name.element;
      if(!same) {
        const { error } = makeMessageFunction(model);
        error(null, path0.location, `Unmanaged association condition can not follow another unmanaged association.`);
      }
    }
  }

  function checkAssociationArgumentStartingWithSelf() {
    if(op && op.val==='xpr') // no check for xpr
      return;
    if(op && op.val!=='=') {
      const { error } = makeMessageFunction(model);
      error(null, op.location, `$self comparison is only allowed with '='`);
    }
  }

}

function isStruct(obj) {
  return has.call(obj, 'elements');
}

function isAssoc(obj) {         // also checks for Compositions
  if (!obj)
    return obj;
  let type = obj._finalType || obj;
  return !!type.target;
}

function isUnmanagedAssociation(obj) {
  return isAssoc(obj) && obj.onCond !== undefined;
}

// Check that required actual parameters on 'node.type' are set, that their values are in the correct range etc.
function checkTypeParameters(node, model) {
  const { error } = makeMessageFunction(model);

  if (node.type) {
    if (node.typeArguments) {
      error(null, node.typeArguments[0].location, `Too many parameters in type reference to '${node.type._artifact.name.absolute}'`);
    }
    let parameters = (node.type._artifact && node.type._artifact.parameters) || [];
    let type = node.type._artifact;
    let absolute = type && type.name && type.name.absolute;

    // does this type has actual type facets?
    let hasTypeFacets = !!parameters.reduce((a,p) => {
      a |= Number(node[p] !== undefined);
      return a;
    }, false);

    // Are all type facets provided?
    if(absolute !== 'cds.Decimal' || hasTypeFacets) {
      for (let name in parameters) {
        let param = parameters[name];
        if (!node[param] && !['cds.hana.ST_POINT', 'cds.hana.ST_GEOMETRY'].includes(absolute))
          error(null, node.type.location, `Actual value for type parameter '${param}' missing in reference to type '${absolute}'`);
      }
    }
    switch (absolute) {
      case 'cds.String':
      case 'cds.Binary':
      case 'cds.hana.VARCHAR': {
        checkTypeParamValue(node, 'length', 'positiveInteger', {min: 1, max: 5000});
        break;
      }
      case 'cds.Decimal': {
        if(hasTypeFacets) {
          checkTypeParamValue(node, 'precision', 'positiveInteger', {max: 38});
          checkTypeParamValue(node, 'scale', 'positiveInteger', {max: node.precision && node.precision.val});
        }
        break;
      }

      case 'cds.hana.BINARY':
      case 'cds.hana.NCHAR':
      case 'cds.hana.CHAR': {
        checkTypeParamValue(node, 'length', 'positiveInteger', {min: 1, max: 2000});
        break;
      }
      case 'cds.hana.ST_POINT':
      case 'cds.hana.ST_GEOMETRY': {
        checkTypeParamValue(node, 'srid', 'positiveInteger', {max: Number.MAX_SAFE_INTEGER});
        break;
      }
    }
  }

  // Check that the value of the type property `paramName` (e.g. length, precision, scale ...) is of `expectedType`
  // (which can currently only be 'positiveInteger') and (optional) the value is in a given range
  function checkTypeParamValue(node, paramName, expectedType, range = undefined) {
    let paramValue = node[paramName] && node[paramName].val;
    if (paramValue == undefined)
      return true;
    switch (expectedType) {
      case 'positiveInteger':
        if (!(Number.isInteger(paramValue) && paramValue >= 0)) {
          error(null, node[paramName].location, `Actual parameter '${paramName}' for '${node.type._artifact.name.absolute}' must be positive integer`);
          return false;
        }
        break;
      default:
        throw 'Unknown "expectedType"';
    }
    if (range) {
      if (range.max && paramValue > range.max) {
        error(null, node[paramName].location, `Actual parameter '${paramName}' for '${node.type._artifact.name.absolute}' is larger than allowed (max: ${range.max})`);
        return false;
      }
      if (range.min && paramValue < range.min) {
        error(null, node[paramName].location, `Actual parameter '${paramName}' for '${node.type._artifact.name.absolute}' is smaller than allowed (min: ${range.min})`);
        return false;
      }
    }
    return true;
  }
}

// Check that min and max cardinalities of 'elem' in 'art' have legal values
function checkCardinality(elem, model) {
  const { error } = makeMessageFunction(model);
  if (!elem.cardinality) {
    return;
  }

  // Max cardinalities must be a positive number or '*'
  for (let prop of ['sourceMax', 'targetMax']) {
    if (elem.cardinality[prop]) {
      if (!(elem.cardinality[prop].literal === 'number' && elem.cardinality[prop].val > 0
            || elem.cardinality[prop].literal === 'string' && elem.cardinality[prop].val === '*')) {
        error(null, elem.cardinality[prop].location, `Element "${elem.name.absolute}.${elem.name.id}": Illegal value "${elem.cardinality[prop].val}" for max cardinality (must be a positive number or "*")`);
      }
    }
  }

  // Min cardinality must be a non-negative number (already checked by parser)
  for(let prop of ['sourceMin', 'targetMin']) {
    if (elem.cardinality[prop]) {
      if (!(elem.cardinality[prop].literal === 'number' && elem.cardinality[prop].val >= 0)) {
        error(null, elem.cardinality[prop].location, `Element "${elem.name.absolute}.${elem.name.id}": Illegal value "${elem.cardinality[prop].val}" for min cardinality (must be a non-negative number)`);
      }
    }
  }

  // If provided, min cardinality must not exceed max cardinality (note that '*' is considered to be >= any number)
  const pair = [[ 'sourceMin', 'sourceMax', 'Source'], [ 'targetMin', 'targetMax', 'Target' ]];
  pair.forEach(p => {
    if (elem.cardinality[p[0]] && elem.cardinality[p[1]] && elem.cardinality[p[1]].literal === 'number'
      && elem.cardinality[p[0]].val > elem.cardinality[p[1]].val) {
      error(null, elem.cardinality.location, `Element "${elem.name.absolute}.${elem.name.id}": ${p[2]} minimum cardinality must not be greater than ${p[2].toLowerCase()} maximum cardinality`);
    }
  });
}

function checkLocalizedElement (elem, model) {
  const { warning } = makeMessageFunction(model);
  // if it is directly a localized element
  if (elem.localized && elem.localized.val) {
    let type = elem._finalType; // could be the element typed with String(5)
    if (type && type.type)
      type = type.type._artifact;
    if (!type || type.name.absolute !== 'cds.String') {
      warning(null, [ elem.localized.location, elem ], {}, 'Keyword "localized" may only be used in combination with type "String"');
    }
  }
}

/**
 * If the given element is not computed, check whether its final type has
 * proper type information.  Useful for checking that `type of` does not refer
 * to a computed element.
 *
 * @param {XSN.Artifact} element
 * @param {XSN.Model} model
 */
function checkElementHasValidTypeOf(element, model) {
  // Computed elements, e.g. "1+1 as foo" in a view don't have a valid type and
  // are skipped here.  Their usage will still be warned about, though.
  // Elements in projections are not tested as well as they don't have the
  // origin's type information copied but reference them in _finalType.
  if (element['@Core.Computed'] || element.origin)
    return;

  checkArtifactHasProperType(element, model);
}

/**
 * Check that there are no .items containing .items.
 *
 * Type definitions and elements are checked - recursion is handled by the semanticChecks
 *
 * @param {object} obj element or type definition
 * @param {object} model the whole model
 */
function checkForItemsChain(obj, model){
  if (obj.items) {
    const itemsType = obj.items.type ? obj.items.type._artifact : obj.items;

    if (itemsType.items){
      const { warning } = makeMessageFunction( model );
      warning('chained-array-of', [ obj.location, obj ], { art: itemsType },
        '"Array of"/"many" must not be chained with $(ART)');
    }
  }
}

/**
 * Check that the given type has no conflicts between its `type` property
 * and its `elements` or `items` property. For example if `type` is not
 * structured but the artifact has an `elements` property then the user
 * made a mistake. This scenario can only happen through CSN and not CDL.
 *
 * @param {XSN.Artifact} artifact
 * @param {XSN.Model} model
 */
function checkTypeStructure(artifact, model) {
  if (!artifact.items && !artifact.elements)
    return;

  const finalType = artifact._finalType;

  // Just a basic check. We do not check that the inner structure of `items`
  // is the same as the type but only that all are arrayed or structured.
  if (artifact.type && artifact.type._artifact) {
    const { warning } = makeMessageFunction(model);

    if (artifact.items && !finalType.items) {
      warning('type-items-mismatch', [ artifact.type.location, artifact ],
            { type: artifact.type, prop: 'items' },
            'Used type $(TYPE) is not arrayed and conflicts with $(PROP) property'
          );

    } else if (artifact.elements && !finalType.elements) {
      warning('type-elements-mismatch', [ artifact.type.location, artifact ],
            { type: artifact.type, prop: 'elements' },
            'Used type $(TYPE) is not structured and conflicts with $(PROP) property'
          );
    }
  } else if (artifact.items) {
    checkTypeStructure(artifact.items, model);
  }
}

module.exports = {
  checkPrimaryKey,
  checkLocalizedSubElement,
  checkManagedAssoc,
  checkVirtualElement,
  checkTypeParameters,
  checkCardinality,
  checkLocalizedElement,
  checkStructureCasting,
  checkElementHasValidTypeOf,
  checkForItemsChain,
  checkTypeStructure
};
