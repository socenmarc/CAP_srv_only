'use strict';

// This file contains functions related to XSN/CSN-location objects as well
// as for semantic locations

const { analyseCsnPath, traverseQuery } = require('../model/csnRefs');

/**
 * Create a location with location properties `filename` and `start` from
 * argument `start`, and location property `end` from argument `end`.
 */
function combinedLocation( start, end ) {
  if (!start)
    return end.location;
  else if (!end)
    return start.location;
  return {
    filename: start.location.filename,
    start: start.location.start,
    end: end && end.location && end.location.end,
  };
}

/**
 * Create an empty location object with the given file name.
 *
 * @param {string} filename
 * @returns {XSN.Location}
 */
function emptyLocation(filename) {
  return {
    filename,
    start: { offset: 0, line: 1, column: 1 },
    end: { offset: 0, line: 1, column: 1 },
  };
}

/**
 * Create an empty location object with the given file name.
 * The end line/column is not set and the location is therefore $weak.
 *
 * @param {string} filename
 * @returns {XSN.Location}
 */
function emptyWeakLocation(filename) {
  return {
    filename,
    start: { offset: 0, line: 1, column: 1 },
    $weak: true,
  };
}

/**
 * Returns a dummy location for built-in definitions.
 *
 * @returns {XSN.Location}
 */
function builtinLocation() {
  return emptyLocation('<built-in>');
}

/**
 * Normalize location: to old-style at the moment, TODO: should switch to new-style
 *
 * @param {object} loc CSN style location
 * @returns {XSN.Location}
 */
function normalizeLocation( loc ) {
  // `file` may be undefined, though it should not.
  // TODO: `loc` may also be a string from $location
  if (!loc || typeof loc !== 'object' || !('file' in loc))
    return loc;
  const location = {
    filename: loc.file,
    start: { line: loc.line || 0, column: loc.col || 0 },
    end: { line: loc.endLine || loc.line || 0, column: loc.endCol || loc.col || 0 },
  };
  if (!loc.endLine)
    location.$weak = true;
  return location;
}

/**
 * Return the source location of the complete dictionary `dict`.  If
 * `extraLocation` is truthy, also consider this location.
 * ASSUMPTION: all entries in the dictionary have a property `location` and
 * `location.filename` has always the same value.
 *
 * @param {object} dict
 * @param {XSN.Location} [extraLocation]
 * @returns {XSN.Location}
 */
function dictLocation( dict, extraLocation ) {
  if (!dict)
    return extraLocation;

  if (!(dict instanceof Array))
    dict = Object.getOwnPropertyNames( dict ).map( name => dict[name] );

  const locations = [].concat( ...dict.map( _objLocations ) );
  if (extraLocation)
    locations.push( extraLocation );

  const min = locations.reduce( (a, b) => (a.start.offset < b.start.offset ? a : b) );
  const max = locations.reduce( (a, b) => ((a.end || a.start).offset > (b.end || b.start).offset ? a : b) );
  return { filename: min.filename, start: min.start, end: max.end };
}

function _objLocations( obj ) {
  return (obj instanceof Array) ? obj.map( o => o.location ) : [ obj.location ];
}


function constructSemanticLocationFromCsnPath(csnPath, model) {
  // Copy because this function shift()s from the path.
  csnPath = [ ...csnPath ];
  const csnDictionaries = [
    'args', 'params', 'enum', 'mixin', 'elements', 'actions', 'definitions',
  ];
  const queryProps = [ 'from', 'where', 'groupBy', 'having', 'orderBy', 'limit', 'offset' ];

  let { query } = analyseCsnPath(
    csnPath,
    model
  );

  // remove definitions
  csnPath.shift();
  const artName = csnPath.shift();
  let currentThing = model.definitions[artName];
  let result = `${ (currentThing && currentThing.kind) ? currentThing.kind : 'artifact' }:${ _quoted(artName) }`;

  if (!currentThing)
    return result;

  if (query)
    query = queryDepth(currentThing.query, query);

  const elements = [];
  let inCsnDict = false;
  let inElement = false;
  let inAction = false;
  let inParam = false;
  let inKeys = false;
  let inRef = false;
  let inEnum = false;
  let inQuery = false;
  let inColumn = false;
  let inMixin = false;
  let inItems = false;

  // for top level actions
  if (currentThing.kind === 'action')
    inAction = true;
  for (const [ index, step ] of csnPath.entries()) {
    currentThing = currentThing[step];
    if (csnDictionaries.includes(step) && !inCsnDict) {
      inCsnDict = true;
      switch (step) {
        case 'elements':
          if (!inElement){
            inElement = true;
            // do not print intermediate items
            inItems = false;
          }
          break;
        case 'actions':
          inAction = true;
          break;
        case 'params':
          inParam = true;
          break;
        case 'enum':
          inElement = false;
          inEnum = true;
          break;
        case 'mixin':
          inMixin = true;
          inQuery = false;
          break;
        default:
          if (inElement) {
            // close element
            result += element();
            inElement = false;
          }
      }
    }
    else if ( inQuery ) {
      if (step === 'SELECT') {
        if (!csnPath[index + 1]) {
          result += select();
        }
        else if (queryProps.includes(csnPath[index + 1]) && !csnPath[index + 2]) {
          const clause = csnPath[index + 1];
          result += select();
          result += `/${ clause }`;
        }
      }
      else if (step === 'columns') {
        result += select();
        result += '/column';
        inColumn = true;
        inQuery = false;
      }
    }
    else if ( inMixin ) {
      if (step === 'on') {
        result += '/on';
        break;
      }
      else {
        result += selectAndMixin(step);
      }
    }
    else if (inEnum) {
      result += elementAndEnum(step);
    }
    else if (!inElement && step === 'query') {
      inQuery = true;
    }
    else if (inElement && step === 'keys') {
      // close element
      result += `${ element() }/key`;
      inElement = false;
      inKeys = true;
    }
    else if (inElement && step === 'on') {
      // close element
      result += `${ element() }/on`;
      inElement = false;
      break;
    }
    else if (inElement && step === 'items') {
      // this is an element called items
      if (csnPath[index - 1] === 'elements' && elements[elements.length - 1] !== 'elements') {
        elements.push(step);
      }
      else {
        inElement = false;
        inItems = true;
      }
    }
    else if (inElement && step === 'elements') {
      // this is an element called elements
      if (csnPath[index - 1] === 'elements')
        elements.push(step);
    }
    else if (inItems && step === 'elements') {
      inElement = true;
      inItems = false;
    }
    else if ( inKeys || inColumn) {
      if (typeof step === 'number') {
        if (currentThing.as)
          result += `:${ _quoted(currentThing.as) }`;
        else
          result += inRef ? `:${ _quoted(currentThing) }` : currentThing.ref ? `:${ _quoted(currentThing.ref.join('.')) }` : '';

        break;
      }
      if ( step === 'ref')
        inRef = true;
    }
    else if (inAction && step === 'returns') {
      result += `/${ step }`;
      break;
    }
    else if (inCsnDict) {
      if (inElement)
        elements.push(step);
      else if (inParam)
        result += param(step);

      else if (inAction)
        result += func(step);

      inCsnDict = false;
    }
  }
  if ( inItems )
    result += `${ element() }/items`;
  else if ( inElement )
    result += element();
  return result;

  function select() {
    let s = '/select';
    s += query.isOnlySelect ? '' : `:${ query.depth }`;
    return s;
  }
  function selectAndMixin(name) {
    return `${ select() }/mixin:${ _quoted(name) }`;
  }
  function element() {
    return `/element:${ _quoted(elements.join('.')) }`;
  }
  function param(name) {
    return `/param:${ _quoted(name) }`;
  }
  function func(name) {
    return `/function:${ _quoted(name) }`;
  }
  function elementAndEnum(name) {
    return `${ element() }/enum:${ _quoted(name) }`;
  }

  /**
   * Traverse rootQuery until targetQuery is found and count the depth,
   * check if targetQuery is only select in entity.
   */
  function queryDepth(rootQuery, targetQuery) {
    let targetQueryDepth = 1;
    let totalQueryDepth = 0;

    let isFound = false;
    traverseQuery(rootQuery, null, (q, querySelect) => {
      if ( querySelect )
        totalQueryDepth += 1;
      if ( querySelect && !isFound)
        targetQueryDepth += 1;
      if (q === targetQuery)
        isFound = true;
    });
    return { depth: targetQueryDepth, isOnlySelect: totalQueryDepth === 1 };
  }
}


function _quoted( name ) {
  return (name) ? `"${ name.replace( /"/g, '""' ) }"` : '<?>'; // sync ";
}


module.exports = {
  combinedLocation,
  emptyLocation,
  emptyWeakLocation,
  builtinLocation,
  normalizeLocation,
  dictLocation,
  constructSemanticLocationFromCsnPath,
};
