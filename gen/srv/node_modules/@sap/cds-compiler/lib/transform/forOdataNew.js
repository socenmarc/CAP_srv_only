'use strict';

const alerts = require('../base/alerts');
const { handleMessages } = require('../base/messages');
const { setProp } = require('../base/model');
const transformUtils = require('./transformUtilsNew');
const { mergeOptions, copyAnnotations } = require('../model/modelUtils');
const { getUtils,
        cloneCsn,
        forEachGeneric,
        forEachDefinition,
        forEachMemberRecursively,
        forEachRef,
        isEdmPropertyRendered,
        isBuiltinType,
        getArtifactDatabaseNameOf,
        getElementDatabaseNameOf } = require('../model/csnUtils');
const { checkCSNVersion } = require('../json/csnVersion');
const validator = require('../checks/csn/validator');
const { validateOnCondition, validateMixinOnCondition } = require('../checks/csn/onConditions');
const validateForeignKeys = require('../checks/csn/foreignKeys');
const { validateDefaultValues }= require('../checks/csn/defaultValues');
const validateAssociationsInArrayOf = require('../checks/csn/assocsInArrayOf');

const { isArtifactInSomeService, getServiceOfArtifact, isLocalizedArtifactInService } = require('./odata/utils');
const typesExposure = require('./odata/typesExposure');
const ReferenceFlattener = require('./odata/referenceFlattener');
const structureFlattener = require('./odata/structureFlattener');
const processForeignKeys = require('./odata/foreignKeys');

// Transformation for ODATA. Expects a CSN 'inputModel', processes it for ODATA.
// The twin of forOdata.js
// The result should be suitable for consumption by EDMX processors (annotations and metadata)
// and also as a final CSN output for the ODATA runtime (when compacted).
// Performs the following transformations:
//
//   (0) Semantic checks before flattening regarding temporal data
//   (1.1) Flatten structured elements (and foreign keys of managed associations pointing to
//       keys that are themselves managed associations).
//       TODO: probably only for OData V2?
//   (1.2) Expose (named or anonymous) structured types used in structured types
//   (1.3) Unravel derived types for elements, actions, action parameters, types and
//       annotations (propagating annotations)
//   (1.4) Mark fields with @odata.on.insert/update as @Core.Computed
//   (1.5) Rename shorthand annotations according to a builtin list.
//       e.g. @label -> @Common.Label or @important: [true|false] -> @UI.Importance: [#High|#Low]
//   (1.6) Check annotations. If annotation starts with '@sap...' it must have a string or boolean value
//  Transformations (1.1), (1.2), (1.3), (1.4), (1.5) and (1.6) are executed during the first walk through the model
//
//   (2.1) For exposed actions and functions that use non-exposed or anonymous structured types,
//       create artificial exposing types
//  Transformation (2.1) is a second walk through the definitions
//
//   (3.1) Generate foreign key fields for managed associations, depends on (1.1) in V4 or flatten case
//   (3.2) Flatten/normalize on-conditions in unmanaged associations
//   (3.3) Check that each service has max one draft root
//  Step (3.1) is in the third walk of the model
//
//   (4.1) Generate artificial draft fields if requested
//   (4.3) Check associations for:
//        - exposed associations do not point to non-exposed targets
//        - structured types must not contain associations for OData V2
//   (4.4) Element must not be an 'array of' for OData V2
//   (4.5) If the association target is annotated with @cds.odata.valuelist, annotate the
//        association with @Common.ValueList.viaAssociation
//   (4.6) Check for @Analytics.Measure and @Aggregation.default
//  Fourth loop: (4.1) to (4.6)
//
//   (5.1) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
//   (5.2) Perform checks for exposed non-abstract entities and views - check media type and
//        key-ness (requires that containers have been identified in the fourth pass (4.2))
//  Fifth walk through the model with (5.1) and (5.2)

module.exports = { transform4odataWithCsn, getServiceNames };

function transform4odataWithCsn(inputModel, options) {

  if (options.messages) reclassifyWarnings(options);
  else if (inputModel.messages) reclassifyWarnings(inputModel);

  // Throw exception in case of errors
  handleMessages(inputModel, options);

  // copy the model as we don't want to change the input model
  // TODO: set protos to null here -> call the function from lib/json/nullprotos3.js
  let csn = cloneCsn(inputModel);

  options = mergeOptions(inputModel.options, options);
  setProp(csn, 'options', options);

  const { error, warning, info, signal } = alerts(csn, options);
  const { error: _error, warning: _warning, info: _info } = alerts.makeMessageFunction(csn, options);

  // the new transformer works only with new CSN
  checkCSNVersion(csn, options);

  const transformers = transformUtils.getTransformers(csn, options, '_');
  const {
    createForeignKeyElement,
    flattenOnCond,
    checkExposedAssoc, toFinalBaseType,
    createAndAddDraftAdminDataProjection, createScalarElement,
    createAssociationElement, createAssociationPathComparison,
    addElement, createAction,
    addAction,
    checkForeignKeys, extractValidFromToKeyElement,
    checkAssignment, checkMultipleAssignments,
    recurseElements,
    setAnnotation,
    renameAnnotation,
    expandStructsInOnConditions,
  } = transformers;

  const csnUtils = getUtils(csn);
  const {
    getCsnDef,
    getFinalType,
    getFinalTypeDef,
    getNamespaceOfArtifact,
    getServiceName,
    hasBoolAnnotation,
    isAssocOrComposition,
    isAssociation,
    isStructured,
    inspectRef,
    artifactRef,
    effectiveType,
  } = csnUtils;

  // are we working with structured OData or not
  const structuredOData = options.toOdata.odataFormat === 'structured' && options.toOdata.version === 'v4';

  // collect all declared non-abstract services from the model
  // use the array when there is a need to identify if an artifact is in a service or not
  let services = getServiceNames(csn);

  //handles reference flattening
  let referenceFlattener = new ReferenceFlattener();
  referenceFlattener.attachPaths(csn);
  referenceFlattener.resolveAllReferences(csn, inspectRef, isStructured);

  // (0) Semantic checks before flattening regarding temporal data and array of
  forEachDefinition(csn, (artifact, artifactName, propertyName, path) => {
    // Gather all element names with @cds.valid.from/to/key
    let validFrom = [], validTo = [], validKey = [];
    recurseElements(artifact, ['definitions', artifactName], (member, path) => {
      let [f, t, k] = extractValidFromToKeyElement(member, path);
      validFrom.push(...f);
      validTo.push(...t);
      validKey.push(...k);
    });
    // Check that @cds.valid.from/to/key is only in valid places
    validFrom.forEach(obj => checkAssignment('@cds.valid.from', obj.element, obj.path, artifact));
    validTo.forEach(obj => checkAssignment('@cds.valid.to', obj.element, obj.path, artifact));
    validKey.forEach(obj => checkAssignment('@cds.valid.key', obj.element, obj.path, artifact));
    checkMultipleAssignments(validFrom, '@cds.valid.from', artifact, artifactName);
    checkMultipleAssignments(validTo, '@cds.valid.to', artifact, artifactName);
    checkMultipleAssignments(validKey, '@cds.valid.key', artifact, artifactName);
    if (validKey.length && !(validFrom.length && validTo.length)) {
      _error(null, path, '@cds.valid.key was used but @cds.valid.from and @cds.valid.to are missing');
    }
  });

  // (1.1) Unravel derived type chains to final one for elements, actions, action parameters (propagating annotations)
  forEachDefinition(csn, (def, defName) => {
    forEachMemberRecursively(def, (member) => {
      if (!member.elements && !member.items) // structured does not have final base type and arrays are covered on the next line
        toFinalBaseType(member);
      if (member.type && member.type.ref && member.elements) // type of was already expanded and we can delete the reference to the type
        delete member.type;
      toFinalBaseType(member.items);
      toFinalBaseType(member.returns);
      toFinalBaseType(member.returns && member.returns.items);
    }, ['definitions', defName]);
  });

  referenceFlattener.attachPaths(csn);

  validator(csn, {
    error, warning, info, signal, inspectRef, effectiveType, artifactRef, csn,
  },
    /* Member Validators   */ [ validateOnCondition, validateForeignKeys, validateAssociationsInArrayOf, validateDefaultValues ],
    /* artifact validators */ [],
    /* query validators   */ [ validateMixinOnCondition ]);

  // Check if structured elements and managed associations are compared in an ON condition
  // and expand these structured elements. This tuple expansion allows all other
  // subsequent procession steps (especially a2j) to see plain paths in ON conditions.
  // If errors are detected, handleMessages will return from further processing

  forEachDefinition(csn, expandStructsInOnConditions);


  // Throw exception in case of errors
  handleMessages(csn, options);

  // (1.1) Unravel derived type chains for types and annotations (propagating annotations)
  forEachDefinition(csn, (def, defName) => {
    if (def.kind !== 'entity') {
      let finalTypeDef = def;
      if (def.type && def.type.ref) {
        finalTypeDef = artifactRef(def.type);
        if (!finalTypeDef.type) {
          _error(null, ['definitions', defName], { name: defName }, `${ defName } has no final type`);
          return;
        }
      }
      if (!isStructured(finalTypeDef)) {
        try {
          toFinalBaseType(def);
        } catch (ex) {
          _error(null, ['definitions', defName], { name: defName }, `Final base type of ${ defName } not found`);
          return
        }
      }
      toFinalBaseType(def.items);
      toFinalBaseType(def.returns);
      toFinalBaseType(def.returns && def.returns.items);
    }
    // If the definition('def' variable) is a type definition and the assigned type of this very same definition('def' variable)
    // is structured type, e.g.:
    //
    // type Struct1 {
    //    a : Integer;
    //    b : Integer;
    //  };
    // type Struct2: Struct1;
    // after compilation the csn looks like this:
    // ...
    // "S.Struct1": {
    //   "kind": "type",
    //   "elements": {
    //     "a": { "type": "cds.Integer" },
    //     "b": { "type": "cds.Integer" }
    //   } },
    // "S.Struct2": {
    //   "kind": "type",
    //   "type": "S.Struct1",
    //   "elements": {
    //     "a": { "type": "cds.Integer" },
    //     "b": { "type": "cds.Integer" }
    //   } } ...
    //
    // "S.Struct2" should looks just like "S.Struct1" => the "type": "S.Struct1" property has to be removed
    if (def.kind === 'type' && def.type && !isBuiltinType(def.type) && !def.type.ref) {
      // elements are already there -> do not show the type
      delete def.type;
    }
    // In case we have in the model something like:
    // type Foo: array of Bar; type Bar: { qux: Integer };
    // In the type Foo we expand the first level of elements of the items or
    // type Foo: array of { qux: Integer };
    if (def.kind === 'type' && def.items && isArtifactInSomeService(defName, services)) {
      if(expandFirstLevelOfArrayed(def)) {
        referenceFlattener.attachPaths(def,['definitions',defName]);
      }
    }
  });

  // (1.2) Mark fields with @odata.on.insert/update as @Core.Computed
  // (1.3) Resolve annotation shorthands,
  // (1.4) Check @cds... annotations
  // (1.5) Flatten structs
  // (1.6) Expose (named or anonymous) structured types used in structured types
  // TODO: only for V2 or via special option???

  if (!structuredOData) {
    structureFlattener(csn, { csnUtils, cloneCsn, error, signal, forEachDefinition, setProp, referenceFlattener, copyAnnotations })
  }

  // structure flattener reports errors, further processing is not safe -> throw exception in case of errors
  handleMessages(inputModel, options);


  // Expose user-defined types and anonymous types
  typesExposure(csn, services, options, csnUtils, signal, referenceFlattener);

  // flatten references, attach new paths
  referenceFlattener.flattenAllReferences(csn);
  referenceFlattener.attachPaths(csn);

  // Process associations - expand, generate foreign keys
  let flatKeys = !structuredOData || (structuredOData && options.toOdata.odataForeignKeys);
  processForeignKeys(csn, flatKeys, { referenceFlattener, csnUtils, transformers })

  // Flatten on-conditions in unmanaged associations
  // This must be done before 4.1, since all composition targets are annotated with @odata.draft.enabled in this step
  forEachDefinition(csn, processOnCond);

  // Fourth walk through the model: Now all artificially generated things are in place
  // (4.1) Generate artificial draft fields if requested
  // TODO: should be done by the compiler - Check associations for valid foreign keys
  // TODO: checkif needed at all: Remove '$projection' from paths in the element's ON-condition
  // (4.2) Check associations for:
  //        - exposed associations do not point to non-exposed targets
  //        - structured types must not contain associations for OData V2
  // (4.3) Element must not be an 'array of' for OData V2
  // (4.4) If the association target is annotated with @cds.odata.valuelist, annotate the
  //      association with @Common.ValueList.viaAssociation
  // (4.5) Check for @Analytics.Measure and @Aggregation.default
  let visitedArtifacts = {};
  forEachDefinition(csn, (def, defName) => {
    if (def.kind === 'entity' || def.kind === 'view') {
      // (4.1) Generate artificial draft fields if requested
      if (def['@odata.draft.enabled']) {
        // Ignore if not part of a service
        if (!isArtifactInSomeService(defName, services)) {
          _warning(null, ['definitions', defName], { art: defName },
            `Ignoring annotation "@odata.draft.enabled" because artifact "${ defName }" is not part of a service`);
        }
        else {
          generateDraftForOdata(def, defName, def, visitedArtifacts);
        }
      }

      for (let elemName in def.elements) {
        let elem = def.elements[elemName];
        // Check for valid foreign keys
        if (isAssocOrComposition(elem.type)) {
          checkForeignKeys(elem, elemName, defName, options);
        }
      }
    }
    forEachMemberRecursively(def, (member, memberName, propertyName, path) => {
      if (isArtifactInSomeService(defName, services) || isLocalizedArtifactInService(defName, services)) {
        let service = getServiceOfArtifact(defName, services);
        // (4.2) Check associations
        if (isAssocOrComposition(member.type)) {
          // Check that exposed associations do not point to non-exposed targets
          checkExposedAssoc(defName, member, memberName, service);

          // CDXCORE-457
          if (def.kind === 'type' && options.toOdata.version === 'v2') {
            _warning(null, path,
              `"${defName}.${memberName}": Structured types must not contain associations for OData V2`);
          }
        }
        // (4.3) CDXCORE-458
        else if (propertyName === 'elements' && member.items) {
          if (options.toOdata.version === 'v2') {
            _error(null, path,
              `"${defName}.${memberName}": Element must not be an "array of" for OData V2`);
          }
          else if (['entity', 'view'].includes(def.kind)) {
            // array of <anonymous type> is not allowed
            // array of T is allowed, if T is in defining service or in namespace 'cds'
            // if (member.items.elements && !member.items.type) {
            //   signal(error`"${defName}.${memberName}": Element must not be an "array of anonymous type"`, path);
            // }
          }
        }

        // (4.4) If the member is an association and the target is annotated with @cds.odata.valuelist,
        // annotate the association with @Common.ValueList.viaAssociation (but only for service member artifacts
        // to avoid CSN bloating). The propagation of the @Common.ValueList.viaAssociation annotation
        // to the foreign keys is done very late in edmPreprocessor.initializeAssociation()
        addCommonValueListviaAssociation(member, memberName);

        // (4.5) https://github.wdf.sap.corp/cdx/cds-compiler/issues/837
        // add check here for @Analytics.Measure and @Aggregation.default
        // @Analytics has scope element
        if (member['@Analytics.Measure'] && !member['@Aggregation.default']) {
          _info(null, path, // ['definitions', defName, 'elements', memberName]
            `'@Analytics.Measure' expects '@Aggregation.default' to be assigned as well in element '${defName}.${memberName}'`,
          );
        }
      }
      visitedArtifacts[defName] = true;
    }, ['definitions', defName]);
  });

  // Fifth walk through the model:
  // (5.1) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
  // (5.2) Perform checks for exposed non-abstract entities and views - check media type and
  //      key-ness (requires that containers have been identified in the fourth pass (4.2))
  let illV2Prefix = RegExp('^(_|[0-9])');
  forEachDefinition(csn, (def, defName) => {
    // (5.1) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
    if (options.toOdata.names) {
      // Skip artifacts that have no DB equivalent anyway
      if (!['service', 'context', 'namespace', 'annotation', 'action', 'function'].includes(def.kind)) {
        def['@cds.persistence.name'] = getArtifactDatabaseNameOf(defName, options.toOdata.names, getNamespaceOfArtifact(defName));
      }
      forEachMemberRecursively(def, (member, memberName, prop) => {
        // Only these are actually required and don't annotate virtual elements in entities or types
        // as they have no DB representation (although in views)
        if (typeof member === 'object' && !['action', 'function'].includes(member.kind) && prop !== 'enum' && (!member.virtual || def.query)) {
          // If we have a 'preserved dotted name' (i.e. we are a result of flattening), use that for the @cds.persistence.name annotation
          if (member._flatElementNameWithDots) {
            memberName = member._flatElementNameWithDots;
          }
          member['@cds.persistence.name'] = getElementDatabaseNameOf(memberName, options.toOdata.names);
        }
      });
    }

    // (5.2) Perform checks for exposed non-abstract entities and views
    if (isArtifactInSomeService(defName, services) && !def.abstract && (def.kind === 'entity' || def.kind === 'view')) {
      /** @type {[string, CSN.Element][]} */
      let mediaTypes = [];
      // Walk the elements

      for (let elemName in def.elements) {
        let elem = def.elements[elemName];

        // For ODATA V2, element names must not start with digit or '_'
        if (options.toOdata.version === 'v2') {
          if (illV2Prefix.test(elemName)) {
            _error(null, ['definitions', defName, 'elements', elemName],
              `"${defName}.${elemName}: Element name must not begin with '${elemName[0]}' for OData V2`);
          }
        }

        // Count keys and elements annotated with @Core.MediaType
        if (elem['@Core.MediaType']) {
          mediaTypes.push([elemName, elem]);
        }
      }

      // Additional checks for ODATA V2 regarding remaining keys
      if (options.toOdata.version === 'v2') {
        // Today only one MediaType is allowed in V2
        if (mediaTypes.length > 1) {
          _error(null, ['definitions', defName], `"${defName}: Multiple elements [${mediaTypes.map(e => e[0]).join(', ')}] annotated with '@Core.MediaType', OData V2 allows only one`);
        }
      }

      // Check media type compatibility for all OData versions
      let allowedTypes = ['cds.String', 'cds.Binary', 'cds.LargeBinary'];
      mediaTypes.forEach(e => {
        if (!allowedTypes.includes(e[1].type)) {
          _error(null, ['definitions', defName, 'elements', e[0]], `"${defName}.${e[0]}": Element annotated with '@Core.MediaType' must be of either type "${allowedTypes.join(', ')}"`);
        }
      });
    }
  });

  // Deal with all kind of annotations manipulations here
  forEachDefinition(csn, (def, defName, propertyName, path) => {
    // (1.5) Resolve annotation shorthands for entities, types, annotations, ...
    renameShorthandAnnotations(def, path);
    // (1.6) check annotations
    checkAnnotations(def, ['definitions', defName]);

    forEachMemberRecursively(def, (member, memberName, propertyName, path) => {
      // (1.2) Mark fields with @odata.on.insert/update as @Core.Computed
      annotateCoreComputed(member);

      // (1.3) Resolve annotation shorthands for elements, actions, action parameters
      renameShorthandAnnotations(member, path);

      // (1.4) check annotations
      checkAnnotations(member, path);
    }, ['definitions', defName]);
  })

  /**
 * Check if any warnings were raised in earlier steps that need to be reclassified - i.e. as errors
 *
 * @param {any} csn The csn
 * @returns {Array} Reclassified messages-Array
 */
  function reclassifyWarnings(csn) {
    return csn.messages.map(message => {
      switch (message.messageId) {
        case 'enum-value-ref':
        case 'check-proper-type-of':
        case 'rewrite-not-supported':
        case 'rewrite-undefined-key':
          message.severity = 'Error';
          break;
      }
      return message;
    });
  }

  // Throw exception in case of errors
  handleMessages(csn, options);

  if (options.messages) setProp(csn, 'messages', options.messages);
  return csn;

  // (1.4) Mark elements that are annotated with @odata.on.insert/update with the annotation @Core.Computed.
  // Implements: CDXCORE-62
  function annotateCoreComputed(node) {
    // If @Core.Computed is explicitly set, don't overwrite it!
    if (node['@Core.Computed']) return;

    // For @odata.on.insert/update, also add @Core.Computed
    if (node['@odata.on.insert'] || node['@odata.on.update'])
      node['@Core.Computed'] = true;
  }

  // (1.5) Rename shorthand annotations within artifact or element 'node' according to a builtin
  // list.
  function renameShorthandAnnotations(node, path) {
    // FIXME: Verify this list - are they all still required? Do we need any more?
    const mappings = {
      '@label': '@Common.Label',
      '@title': '@Common.Label',
      '@description': '@Core.Description',
      '@ValueList.entity': '@Common.ValueList.entity',
      '@ValueList.type': '@Common.ValueList.type',
      '@Capabilities.Deletable': '@Capabilities.DeleteRestrictions.Deletable',
      '@Capabilities.Insertable': '@Capabilities.InsertRestrictions.Insertable',
      '@Capabilities.Updatable': '@Capabilities.UpdateRestrictions.Updatable',
      '@Capabilities.Readable': '@Capabilities.ReadRestrictions.Readable',
    }

    let rewriteCapabilities = true;
    if (node['@readonly'] && node['@insertonly'] && ['entity', 'view'].includes(node.kind)) {
      rewriteCapabilities = false;
      _warning(null, path, '"@readonly" and "@insertonly" cannot be assigned in combination');
    }
    for (let name in node) {
      // Rename according to map above
      if (mappings[name] != undefined)
        renameAnnotation(node, name, mappings[name]);

      // Special case: '@important: [true|false]' becomes '@UI.Importance: [#High|#Low]'
      if (name === '@important') {
        renameAnnotation(node, name, '@UI.Importance');
        let annotation = node['@UI.Importance'];
        node['@UI.Importance'] = { '#': annotation ? 'High' : 'Low' }
      }

      // Special case: '@readonly' becomes a triplet of capability restrictions for entities,
      // but '@Core.Immutable' for everything else.
      if (rewriteCapabilities) {
        if (name === '@readonly') {
          if (node.kind === 'entity' || node.kind === 'view') {
            setAnnotation(node, '@Capabilities.DeleteRestrictions.Deletable', false);
            setAnnotation(node, '@Capabilities.InsertRestrictions.Insertable', false);
            setAnnotation(node, '@Capabilities.UpdateRestrictions.Updatable', false);
          } else {
            renameAnnotation(node, name, '@Core.Computed');
          }
        }
        // @insertonly is effective on entities/queries only
        else if (name === '@insertonly') {
          if (node.kind === 'entity' || node.kind === 'view') {
            setAnnotation(node, '@Capabilities.DeleteRestrictions.Deletable', false);
            setAnnotation(node, '@Capabilities.ReadRestrictions.Readable', false);
            setAnnotation(node, '@Capabilities.UpdateRestrictions.Updatable', false);
          }
        }
      }
      // Only on element level: translate @mandatory
      if (name === '@mandatory' && node.kind === undefined && node['@Common.FieldControl'] === undefined) {
        setAnnotation(node, '@Common.FieldControl', { '#': 'Mandatory' });
      }

      if (name === '@assert.format') setAnnotation(node, '@Validation.Pattern', node['@assert.format']);

      if (name === '@assert.range') {
        if (Array.isArray(node['@assert.range']) && node['@assert.range'].length === 2) {
          setAnnotation(node, '@Validation.Minimum', node['@assert.range'][0]);
          setAnnotation(node, '@Validation.Maximum', node['@assert.range'][1]);
        } else if (node.enum) {
          let enumValue = Object.keys(node.enum).map( enumName => {
            let result = { '@Core.SymbolicName': enumName };
            if (node.enum[enumName].val) result.Value = node.enum[enumName].val;
            return result;
          });
          setAnnotation(node, '@Validation.AllowedValues', enumValue);
        }
      }
    }
  }

  // (1.6) Apply checks to all annotations in the model
  // node: artifact/element/action/function/parameter/... that carries the annotations
  function checkAnnotations(node, defPath) {
    // currently there is only one check: annotations @sap:... must have a string or boolean value
    //   or no value (as shorcut for boolean value true)
    let annoNames = Object.keys(node).filter(x => x.startsWith('@sap.'));
    for (let name of annoNames) {
      if (typeof node[name] !== 'boolean' && typeof node[name] !== 'string') {
        _warning(null, defPath, { name }, `Annotation "${ name }" must have a string or boolean value`);
      }
    }
  }

  // In case we have in the model something like:
  // type Foo: array of Bar; type Bar: { qux: Integer };
  // In the type Foo we expand the first level of elements of the items like we have in CDL this:
  // type Foo: array of { qux: Integer };
  function expandFirstLevelOfArrayed(def) {
    if (def.items.type && !isBuiltinType(def.items.type)) {
      let finalType = getFinalTypeDef(def.items.type);
      if (isStructured(finalType)) {
        def.items.elements = cloneCsn(finalType.elements);
        delete def.items.type;
        return true;
      }
    }
    return false;
  }

  // (3.2) Flatten on-conditions in unmanaged associations
  function processOnCond(def, defName) {
    const rootPath = ['definitions', defName];
    forEachMemberRecursively(def, (member, memberName, prop, subpath) => {
      // (3.2) Flatten/normalize on-conditions in unmanaged associations
      if (member.type && isAssocOrComposition(member.type) && member.on) {
        if (!structuredOData) // flat-mode
          flattenOnCond(member, memberName, def.elements, defName, rootPath.concat(subpath));
        else // structured-mode
          normalizeOnCondForStructuredMode(member)
      }
    });
  }

  // The function performs normalization for on-conditions in 'structured'-mode (for odata) as follows:
  // 1. removes leading $self in references
  function normalizeOnCondForStructuredMode(assoc) {
    if (!assoc.on) return; // nothing to do
    forEachRef(assoc, (ref, node) => {
      // remove leading $self when at the begining of a ref
      if (ref.length > 1 && ref[0] === '$self')
        node.ref.splice(0, 1);
    });
  }

  // (4.1) Generate all that is required in ODATA for draft enablement of 'artifact' into the artifact,
  // into its transitively reachable composition targets, and into the model.
  // 'rootArtifact' is the root artifact where composition traversal started.

  // Constraints
  // Draft Root: Exactly one PK of type UUID
  // Draft Node: One PK of type UUID + 0..1 PK of another type
  // Draft Node: Must not be reachable from multiple draft roots
  function generateDraftForOdata(artifact, artifactName, rootArtifact, visitedArtifacts) {
    // Sanity check
    if (!isArtifactInSomeService(artifactName, services)) {
      throw new Error('Expecting artifact to be part of a service: ' + JSON.stringify(artifact));
    }
    // Nothing to do if already draft-enabled (composition traversal may have circles)
    if ((artifact['@Common.DraftRoot.PreparationAction'] || artifact['@Common.DraftNode.PreparationAction'])
      && artifact.actions && artifact.actions.draftPrepare) {
      return;
    }

    // extract EDM exposed keys for UUID inspection
    let keys = [];
    forEachGeneric(artifact, 'elements', (elt) => {
      if (elt.key && elt.key === true && isEdmPropertyRendered(elt, options))
        keys.push(elt);
    });

    // A draft enabled entity should *expose* exactly one primary key of type cds.UUID in the EDM document
    if (keys.length !== 1) {
      _warning(null, ['definitions', artifactName], `"${artifactName}": "@odata.draft.enabled" - Entity should expose exactly one key element`);
    }

    let uuidCount = keys.reduce((uuidCount, k) => {
      return k.type === 'cds.UUID' ? ++uuidCount : uuidCount;
    }, 0);
    if (uuidCount === 0) {
      _warning(null, ['definitions', artifactName], `"${artifactName}": "@odata.draft.enabled" - Entity key element should be of type "cds.UUID"`);
    }

    // Generate the DraftAdministrativeData projection into the service, unless there is already one
    let draftAdminDataProjectionName = `${getServiceOfArtifact(artifactName, services)}.DraftAdministrativeData`;
    let draftAdminDataProjection = csn.definitions[draftAdminDataProjectionName];
    if (!draftAdminDataProjection) {
      draftAdminDataProjection = createAndAddDraftAdminDataProjection(getServiceOfArtifact(artifactName, services));
    }
    // Report an error if it is not an entity or not what we expect
    if (draftAdminDataProjection.kind !== 'entity' || !draftAdminDataProjection.elements['DraftUUID']) {
      _error(null, ['definitions', draftAdminDataProjectionName], { name: draftAdminDataProjectionName },
        `Generated entity "${ draftAdminDataProjectionName }" conflicts with existing artifact`);
    }
    // Generate the annotations describing the draft actions (only draft roots can be activated/edited)
    if (artifact == rootArtifact) {
      artifact['@Common.DraftRoot.ActivationAction'] = 'draftActivate';
      artifact['@Common.DraftRoot.EditAction'] = 'draftEdit';
      artifact['@Common.DraftRoot.PreparationAction'] = 'draftPrepare';
    } else {
      artifact['@Common.DraftNode.PreparationAction'] = 'draftPrepare';
    }

    for (let elemName in artifact.elements) {
      let elem = artifact.elements[elemName];
      // Make all non-key elements nullable
      if (elem.notNull && elem.key !== true) {
        delete elem.notNull;
      }
    }
    // Generate the additional elements into the draft-enabled artifact

    // key IsActiveEntity : Boolean default true
    let isActiveEntity = createScalarElement('IsActiveEntity', 'cds.Boolean', true, true, false);
    isActiveEntity.IsActiveEntity['@UI.Hidden'] = true;
    addElement(isActiveEntity, artifact, artifactName);

    // HasActiveEntity : Boolean default false
    let hasActiveEntity = createScalarElement('HasActiveEntity', 'cds.Boolean', false, false, true);
    hasActiveEntity.HasActiveEntity['@UI.Hidden'] = true;
    addElement(hasActiveEntity, artifact, artifactName);

    // HasDraftEntity : Boolean default false;
    let hasDraftEntity = createScalarElement('HasDraftEntity', 'cds.Boolean', false, false, true);
    hasDraftEntity.HasDraftEntity['@UI.Hidden'] = true;
    addElement(hasDraftEntity, artifact, artifactName);

    // @odata.contained: true
    // DraftAdministrativeData : Association to one DraftAdministrativeData;
    let draftAdministrativeData = createAssociationElement('DraftAdministrativeData', draftAdminDataProjectionName, true);
    draftAdministrativeData.DraftAdministrativeData.cardinality = { max: 1, };
    draftAdministrativeData.DraftAdministrativeData['@odata.contained'] = true;
    draftAdministrativeData.DraftAdministrativeData['@UI.Hidden'] = true;
    addElement(draftAdministrativeData, artifact, artifactName);

    // Note that we need to do the ODATA transformation steps for managed associations
    // (foreign key field generation, generatedFieldName) by hand, because the corresponding
    // transformation steps have already been done on all artifacts when we come here)
    let uuidDraftKey = draftAdministrativeData.DraftAdministrativeData.keys.filter(key => key.ref && key.ref.length === 1 && key.ref[0] === 'DraftUUID');
    if (uuidDraftKey && uuidDraftKey[0]) {
      uuidDraftKey = uuidDraftKey[0]; // filter returns an array, but it has only one element
      let path = ['definitions', artifactName, 'elements', 'DraftAdministrativeData', 'keys', 0];
      createForeignKeyElement(draftAdministrativeData.DraftAdministrativeData, 'DraftAdministrativeData', uuidDraftKey, artifact, artifactName, path);
    }
    // SiblingEntity : Association to one <artifact> on (... IsActiveEntity unequal, all other key fields equal ...)
    let siblingEntity = createAssociationElement('SiblingEntity', artifactName, false);
    siblingEntity.SiblingEntity.cardinality = { max: 1 };
    addElement(siblingEntity, artifact, artifactName);
    // ... on SiblingEntity.IsActiveEntity != IsActiveEntity ...
    siblingEntity.SiblingEntity.on = createAssociationPathComparison('SiblingEntity', 'IsActiveEntity', '!=', 'IsActiveEntity');

    // Iterate elements
    for (let elemName in artifact.elements) {
      let elem = artifact.elements[elemName];
      if (elemName !== 'IsActiveEntity' && elem.key) {
        // Amend the ON-condition above:
        // ... and SiblingEntity.<keyfield> = <keyfield> ... (for all key fields except 'IsActiveEntity')
        let cond = createAssociationPathComparison('SiblingEntity', elemName, '=', elemName);
        cond.push('and');
        cond.push(...siblingEntity.SiblingEntity.on);
        siblingEntity.SiblingEntity.on = cond;
      }

      // Draft-enable the targets of composition elements (draft nodes), too
      // TODO rewrite
      if (elem.target && elem.type && getFinalType(elem.type) === 'cds.Composition') {
        let draftNode = csn.definitions[elem.target];

        // Ignore if that is our own draft root
        if (draftNode != rootArtifact) {
          // Barf if the draft node has @odata.draft.enabled itself
          if (hasBoolAnnotation(draftNode, '@odata.draft.enabled', true)) {
            _error(null, ['definitions', artifactName, 'elements', elemName], `"${artifactName}.${elemName}": Composition in draft-enabled entity cannot lead to another entity with "@odata.draft.enabled"`);
          }
          // Ignore composition if not part of a service
          else if (!getServiceName(elem.target)) {
            _warning(null, ['definitions', artifactName, 'elements', elemName], `Target "${elem.target}" of composition "${artifactName}.${elemName}" cannot be a draft node because it is not part of a service`);
            continue;
          }
          else if (hasBoolAnnotation(draftNode, '@odata.draft.enabled', false)) {
            continue;
          }
          else {
            // Generate draft stuff into the target
            generateDraftForOdata(draftNode, elem.target, rootArtifact, visitedArtifacts);
          }
        }
      }
    }

    // Generate the actions into the draft-enabled artifact (only draft roots can be activated/edited)

    // action draftPrepare (SideEffectsQualifier: String) return <artifact>;
    let draftPrepare = createAction('draftPrepare', artifactName, 'SideEffectsQualifier', 'cds.String');
    addAction(draftPrepare, artifact, artifactName);

    if (artifact == rootArtifact) {
      // action draftActivate() return <artifact>;
      let draftActivate = createAction('draftActivate', artifactName);
      addAction(draftActivate, artifact, artifactName);

      // action draftEdit (PreserveChanges: Boolean) return <artifact>;
      let draftEdit = createAction('draftEdit', artifactName, 'PreserveChanges', 'cds.Boolean');
      addAction(draftEdit, artifact, artifactName);
    }
  }

  // CDXCORE-481
  // (4.5) If the member is an association whose target has @cds.odata.valuelist annotate it
  // with @Common.ValueList.viaAssociation.
  // This must be done before foreign keys are calculated and the annotations are propagated
  // to them. This will make sure that association and all its foreign keys are annotated with
  // Common.ValueList in the final EDM.
  // Do this only if the association is navigable and the enclosing artifact is
  // a service member (don't pollute the CSN with unnecessary annotations).
  // TODO: test???
  function addCommonValueListviaAssociation(member, memberName) {
    let vlAnno = '@Common.ValueList.viaAssociation';
    if (isAssociation(member.type)) {
      let navigable = member['@odata.navigable'] !== false; // navigable disabled only if explicitly set to false
      let targetDef = getCsnDef(member.target);
      if (navigable && targetDef['@cds.odata.valuelist'] && !member[vlAnno]) {
        member[vlAnno] = { '=': memberName };
      }
    }
  }

} // transform4odataWithCsn

// Return an array of non-abstract service names contained in compacted 'model'
function getServiceNames(model) {
  let result = [];
  forEachDefinition(model, (artifact, artifactName) => {
    if (artifact.kind === 'service' && !artifact.abstract) {
      result.push(artifactName);
    }
  });
  return result;
}
