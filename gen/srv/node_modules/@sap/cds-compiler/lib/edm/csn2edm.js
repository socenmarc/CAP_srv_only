'use strict';

/* eslint max-lines:off */
/* eslint max-statements-per-line:off */

let NAVPROP_TRENNER = '_';
let VALUELIST_NAVPROP_PREFIX = '';

const edmUtils = require('./edmUtils.js')
const { initializeModel } = require('./edmPreprocessor.js');
const translate = require('./annotations/genericTranslation.js');
const alerts = require('../base/alerts');
const { setProp } = require('../base/model');
const { cloneCsn, isEdmPropertyRendered } = require('../model/csnUtils');
const { checkCSNVersion } = require('../json/csnVersion');
const builtins = require('../compiler/builtins');
const { handleMessages } = require('../base/messages');

/*
OData V2 spec 06/01/2017 PDF version is available from here:
https://msdn.microsoft.com/en-us/library/dd541474.aspx
*/

/* invocation:
  metadata: csn2edm(forOdata, { version:'v2' })
*/

function csn2edm(_csn, serviceName, _options) {
  return csn2edmAll(_csn, _options, serviceName)[serviceName];
}

function csn2edmAll(_csn, _options, serviceName=undefined) {
  // get us a fresh model copy that we can work with
  let csn = cloneCsn(_csn);

  // use original options for messages; cloned CSN for semantic location
  const messageFunctions = alerts.makeMessageFunction(csn, _options);
  const { info, warning, error } = messageFunctions;
  checkCSNVersion(csn, _options);

  let rc = Object.create(null);

  let [ services, options ] = initializeModel(csn, _options);
  const Edm = require('./edm.js')(options);

  let v = options.v;
  if(services.length === 0) {
    info(null, null, `No Services in model`);
    return rc;
  }

  if(serviceName) {
    let serviceCsn = services.filter(s => s.name == serviceName)[0];
    if(serviceCsn == undefined) {
      warning(null, null, `No service definition with name "${serviceName}" found in the model`);
    }
    else {
      rc[serviceName] = createEdm(serviceCsn);
    }
  }
  else {
    rc = services.reduce((services, serviceCsn) => {
      services[serviceCsn.name] = createEdm(serviceCsn);
      return services; }, rc);
  }
  handleMessages(csn, options);
  return rc;

  //--------------------------------------------------------------------------------
  // embedded functions
  //--------------------------------------------------------------------------------
  function createEdm(serviceCsn) {

    function baseName(str, del) { let l = str.lastIndexOf(del);   // eslint-disable-line no-unused-vars
      return (l >= 0) ? str.slice(l+del.length, str.length) : str; }

    // if we have a real alias take it, otherwise use basename of service
    // let alias = serviceCsn.alias || baseName(baseName(serviceCsn.name, '::'), '.');
    // FIXME: UI5 cannot deal with spec conforming simpleid alias names

    const service = new Edm.DataServices(v);
    const edm = new Edm.Edm(v, service);

    /* -------------------------------------------------
      Multi Schema generation in V4:

      If a service contains nested contexts (exactly one level)!
      then these contexts are interpreted as additional schemas:

      service MainSchema {
        entity A { toD: association to SideSchema1.D; };
        context SideSchema1 {
          entity D {};
        }
        context SideSchema2 {
          ...
        }
      };

      Only the main schema has an entity container
      Nested definitions are identified by their name in
      definitions:

      MainSchema.A: {},
      MainSchema.SideSchema1.D: {},
      MainSchema.SideSchema2....

      This requires that the names of all members
      of the side elements must be stripped to reflect the
      schema local name (with single schema prefix).
      Also all schema members need to be grouped into
      their respective schemas.

      All type references inside the EDM sub nodes must
      also be rewritten to address the individual schema
      entries.
      -----------------------------------------------*/

    if(options.isV4()) {
      // tunnel schema xref and servicename in options to edm.Typebase to rectify
      // type references that are eventually also prefixed with the service schema name.
      options.serviceName = serviceCsn.name;
      options.fqSchemaXRef = [serviceCsn.name];

      const schemas = { [serviceCsn.name]: { name: serviceCsn.name, fqName: serviceCsn.name, _csn: serviceCsn, container: true, definitions: Object.create(null) } };
      Object.keys(csn.definitions).reduce((schemas, fqName) => {
        const art = csn.definitions[fqName];
        // add sub schemas
        if(fqName.startsWith(serviceCsn.name + '.') && art.kind === 'context') {
          options.fqSchemaXRef.push(fqName);
          // strip the toplevel service schema name
          const name = fqName.replace(serviceCsn.name + '.', '');
          schemas[name] = { name, fqName, _csn: art, container: false, definitions: Object.create(null) };
        }
        return schemas;
      }, schemas);

      // fill the schemas, unfortunately this can't be done in one step
      // as all possible prefix combinations must be known in fqSchemaXRef
      Object.keys(csn.definitions).reduce((schemas, name) => {
        const art = csn.definitions[name];

        // Identify service members by their definition name only, this allows
        // to let the internal object.name have the sub-schema name.
        let schemaName = options.fqSchemaXRef.reduce((a, n) => {
          if(name.startsWith( n + '.')) a = n;
          return a; }, undefined);

        if(schemaName && art.kind !== 'context') {
          // strip the toplevel serviceName from object.name except if the schema name is the service name itself
          // proxy names are not prefixed, as they need to be reused.
          if(schemaName !== serviceCsn.name) {
            name = art.name = name.replace(serviceCsn.name + '.', '');
            schemaName = schemaName.replace(serviceCsn.name + '.', '');
          }
          schemas[schemaName].definitions[name] = art;
        }
        return schemas;
      }, schemas);


      /*
        References into other Schemas

        References are top level elements in an EDM. However,
        they are valid per service only, so a special link
        object needs to be created that link into the target
        schema.

        Technically these are also contexts but with kind='reference'

        As they are not part of the official CSN spec, they are created
        transiently in the type/proxy exposure.

        ref = { kind: 'reference',
          name: targetSchemaName,
          ref: { Uri },
          inc: { Namespace: targetSchemaName, optionalAlias },
          $mySchemaName: targetSchemaName,
          $proxy: true
        };

      */
      const references = Object.keys(csn.definitions).reduce((references, fqName) => {
        const art = csn.definitions[fqName];
        // add references
        if(fqName.startsWith(serviceCsn.name + '.') && art.kind === 'reference') {
          options.fqSchemaXRef.push(fqName);
          references.push(art);
        }
        return references;
      }, []);

      // bring the schemas in alphabetical order, service first, root last
      const schemaNames = Object.keys(schemas).filter(n => n !== 'root' && n !== serviceCsn.name).sort();
      schemaNames.splice(0,0, serviceCsn.name);
      if(schemas.root)
        schemaNames.push('root');

      // finally create the schemas and register them in the service.
      schemaNames.forEach(name => {
        const schema = schemas[name];
        service.append(createSchema(schema));
      });

      references.forEach(ref => {
        let r = new Edm.Reference(v, ref.ref);
        r.append(new Edm.Include(v, ref.inc))
        edm._defaultRefs.push(r);

      });
    }
    else {
      const schema = { name: serviceCsn.name, _csn: serviceCsn, container: true, definitions: csn.definitions };
      const LeadSchema = createSchema(schema);
      service.append(LeadSchema);
    }

    createAnnotations(edm);
    return edm

    function createSchema(schema) {

      const Schema = new Edm.Schema(v, schema.name, undefined /* unset alias */, schema._csn, /* annotations */ [], schema.container);

      // now namespace and alias are used to create the fullQualified(name)
      const schemaNamePrefix = schema.name + '.'
      const schemaAliasPrefix = schemaNamePrefix;
      const schemaCsn = schema;
      let navigationProperties = [];

      /* create the entitytypes and sets
        Do not create an entity set if:
            V4 containment: _containerEntity is set and not equal with the artifact name
            Entity starts with 'localserviceNameized.' or ends with '_localized'
      */
      edmUtils.foreach(schemaCsn.definitions,
        a => edmUtils.isEntityOrView(a) && !a.abstract && a.name.startsWith(schemaNamePrefix),
        createEntityTypeAndSet
      );
      // create unbound actions/functions
      edmUtils.foreach(schemaCsn.definitions, a => edmUtils.isActionOrFunction(a) && a.name.startsWith(schemaNamePrefix),
        (options.isV4()) ? createActionV4 : createActionV2);

    // create the complex types (don't render aspects by using $syntax hack until kind='aspect' is available)
      edmUtils.foreach(schemaCsn.definitions, a => !(['aspect','event'].includes(a.kind) || a.$syntax === 'aspect') && edmUtils.isStructuredType(a) && a.name.startsWith(schemaNamePrefix), createComplexType);

      if(options.isV4())
      {
        edmUtils.foreach(schemaCsn.definitions,
        artifact => edmUtils.isDerivedType(artifact) &&
        !edmUtils.isAssociationOrComposition(artifact) &&
        artifact.name.startsWith(schemaNamePrefix),
          createTypeDefinition);
      }

      // fetch all exising children names in a map
      let NamesInSchemaXRef = Schema._children.reduce((acc, cur) => {
        if(acc[cur.Name] === undefined) {
          acc[cur.Name] = [ cur ];
        } else {
          acc[cur.Name].push(cur);
        }
        return acc;
      }, Object.create(null) );

      navigationProperties.forEach(np => {
        if(options.isV4()) {
        // V4: No referential constraints for Containment Relationships
          if((!np.isContainment() || (options.renderForeignKeys)) && !np.isToMany())
            np.addReferentialConstraintNodes();
        }
        else
        addAssociation(np);
      });

      // remove EntityContainer if empty
      if(Schema._ec && Schema._ec._children.length === 0) {
        let pos = Schema._children.indexOf(Schema._ec);
        Schema._children.splice(pos, 1);
      }
      if(Schema._children.length === 0) {
        // FIXME: Location for sub schemas?
        warning(null, ['definitions', Schema.Namespace], `Schema "${Schema.Namespace}" is empty`);
      }

      for(let name in NamesInSchemaXRef) {
        if(NamesInSchemaXRef[name].length > 1) {
          let artifactName = `${Schema.Namespace}.${name}`;
          error(null, ['definitions', artifactName], `Duplicate name "${name}" in Schema "${Schema.Namespace}"`);
        }
      }
      return Schema;

      function createEntityTypeAndSet(entityCsn)
      {
        let EntityTypeName = entityCsn.name.replace(schemaNamePrefix, '');
        let EntitySetName = (entityCsn.entitySetName || entityCsn.name).replace(schemaNamePrefix, '');

        let [ properties, hasStream ] = createProperties(entityCsn);

        if(properties.length === 0) {
          warning(null, ['definitions', entityCsn.name], `EntityType "${schema.name}.${EntityTypeName}" has no properties`);
        } else if(entityCsn.$edmKeyPaths.length === 0) {
          warning(null, ['definitions', entityCsn.name], `EntityType "${schema.name}.${EntityTypeName}" has no primary key`);
        }

        // construct EntityType attributes
        let attributes = { Name : EntityTypeName };

        // CDXCORE-CDXCORE-173
        if(options.isV2() && hasStream)
          attributes['m:HasStream'] = hasStream;

        Schema.append(new Edm.EntityType(v, attributes, properties, entityCsn));

        if (Schema._ec && entityCsn.$hasEntitySet)
        {
          /** @type {object} */
          let containerEntry;
          let singleton = entityCsn['@odata.singleton'];
          let hasNullable = entityCsn['@odata.singleton.nullable'] !== undefined &&
            entityCsn['@odata.singleton.nullable'] !== null;

          if(singleton || ((singleton === undefined || singleton === null) && hasNullable)) {
            containerEntry = new Edm.Singleton(v, { Name: EntitySetName, Type: fullQualified(EntityTypeName) }, entityCsn);
            if(entityCsn['@odata.singleton.nullable'])
              containerEntry.Nullable= true;
          }
          else {
            containerEntry = new Edm.EntitySet(v, { Name: EntitySetName, EntityType: fullQualified(EntityTypeName) }, entityCsn);
          }

          // V4: Create NavigationPropertyBinding in EntitySet
          // if NavigationProperty is not a Containment and if the target is not a containee
          if(options.isV4())
            properties.filter(np =>
              np instanceof Edm.NavigationProperty &&
              // @ts-ignore TypeScript does not recognize these properties on type NavigationProperty
              !np.isContainment() && !edmUtils.isContainee(np._targetCsn) && !np._targetCsn.$proxy && !np._targetCsn.$externalRef
            ). forEach(np =>
                containerEntry.append(np.createNavigationPropertyBinding(schemaNamePrefix)));

          Schema._ec.append(containerEntry);
        }

        // put actions behind entity types in Schema/EntityContainer
        edmUtils.forAll(entityCsn.actions, (a, n) => {
          (options.isV4()) ? createActionV4(a, n, entityCsn)
                          : createActionV2(a, n, entityCsn)
        });
      }

      // add bound/unbound actions/functions for V4
      function createActionV4(actionCsn, name, entityCsn=undefined)
      {
        let iAmAnAction = actionCsn.kind === 'action';

        let actionName = actionCsn.name.replace(schemaNamePrefix, '');

        let attributes = { Name: actionName, IsBound : false };

        if(!iAmAnAction)
          attributes.IsComposable = false;

        /** @type {object} */
        let actionNode = (iAmAnAction) ? new Edm.Action(v, attributes)
                                      : new Edm.FunctionDefinition(v, attributes);

        // bpName is eventually used later for EntitySetPath
        let bpNameAnno = actionCsn['@cds.odata.bindingparameter.name'];
        let bpName = bpNameAnno !== undefined ? (bpNameAnno['='] || bpNameAnno) : 'in';

        if(entityCsn != undefined)
        {
          actionNode.IsBound = true;
          let bpType = fullQualified(entityCsn.name);
          // Binding Parameter: 'in' at first position in sequence, this is decisive!
          if(actionCsn['@cds.odata.bindingparameter.collection'])
            actionNode.append(new Edm.Parameter(v, { Name: bpName, Type: bpType, Collection:true } ));
          else
            actionNode.append(new Edm.Parameter(v, { Name: bpName, Type: bpType } ));
        }
        else if(Schema._ec)// unbound => produce Action/FunctionImport
        {
          /** @type {object} */
          let actionImport = iAmAnAction
            ? new Edm.ActionImport(v, { Name: actionName, Action : fullQualified(actionName) })
            : new Edm.FunctionImport(v, { Name: actionName, Function : fullQualified(actionName) });

          let rt = actionCsn.returns && ((actionCsn.returns.items && actionCsn.returns.items.type) || actionCsn.returns.type);
          if(rt) // add EntitySet attribute only if return type is a non abstract entity
          {
            let definition = schemaCsn.definitions[rt];
            if(definition && definition.kind === 'entity' && !definition.abstract)
            {
              actionImport.EntitySet = rt.replace(schemaNamePrefix, '');
            }
          }
          Schema._ec.append(actionImport);
        }

        // Parameter Nodes
        edmUtils.forAll(actionCsn.params, (parameterCsn, parameterName) => {
          actionNode.append(new Edm.Parameter(v, { Name: parameterName }, parameterCsn ));
        });

        // return type if any
        if(actionCsn.returns) {
          actionNode._returnType = new Edm.ReturnType(v, actionCsn.returns);
          // if binding type matches return type add attribute EntitySetPath
          if(entityCsn != undefined && fullQualified(entityCsn.name) === actionNode._returnType._type) {
            actionNode.EntitySetPath = bpName;
          }
        }
        Schema.addAction(actionNode);
      }

      // add bound/unbound actions/functions for V2
      function createActionV2(actionCsn, name, entityCsn=undefined)
      {
        /** @type {object} */
        let functionImport = new Edm.FunctionImport(v, { Name: name.replace(schemaNamePrefix, '') } );

        // inserted now to maintain attribute order with old odata generator...
        /*
          V2 says (p33):
          * If the return type of FunctionImport is a collection of entities, the EntitySet
            attribute is defined.
          * If the return type of FunctionImport is of ComplexType or scalar type,
            the EntitySet attribute cannot be defined.
          The spec doesn't mention single ET: Ralf Handls confirmed that there is a gap
          in the spec and advised mention it as in V4
        */

        let rt = actionCsn.returns && ((actionCsn.returns.items && actionCsn.returns.items.type) || actionCsn.returns.type);
        if(rt) // add EntitySet attribute only if return type is an entity
        {
          let defintion = schemaCsn.definitions[rt];
          if(defintion && edmUtils.isEntityOrView(defintion))
          {
            functionImport.EntitySet = rt.replace(schemaNamePrefix, '');
          }
        }

        if(actionCsn.returns)
          functionImport.ReturnType = getReturnType(actionCsn);

        if(actionCsn.kind === 'function')
          functionImport.setXml( {'m:HttpMethod': 'GET' });
        else if(actionCsn.kind === 'action')
          functionImport.setXml( {'m:HttpMethod': 'POST'});
        else
          throw Error('Please debug me: Neither function nor action');

        if(entityCsn != undefined)
        {
          // Make bound function names always unique as per Ralf's recommendation
          functionImport.setXml( {'sap:action-for':  fullQualified(entityCsn.name) } );
          functionImport.Name = entityCsn.name.replace(schemaNamePrefix, '') + '_' + functionImport.Name;

          // Binding Parameter: Primary Keys at first position in sequence, this is decisive!
          // V2 XML: Nullable=false is set because we reuse the primary key property for the parameter
          edmUtils.foreach(entityCsn.elements,
            elementCsn => elementCsn.key && !edmUtils.isAssociationOrComposition(elementCsn),
            (elementCsn, elementName) => {
              functionImport.append(new Edm.Parameter(v, { Name: elementName }, elementCsn, 'In' ));
            }
          );
        }

        // is this still required?
        for (let p in actionCsn)
          if (p.match(/^@sap\./))
            functionImport.setXml( { ['sap:' + p.slice(5).replace(/\./g, '-')] : actionCsn[p] });

        // then append all other parameters
        // V2 XML: Parameters that are not explicitly marked as Nullable or NotNullable in the CSN must become Nullable=true
        // V2 XML spec does only mention default Nullable=true for Properties not for Parameters so omitting Nullable=true let
        // the client assume that Nullable is false.... Correct Nullable Handling is done inside Parameter constructor
        edmUtils.forAll(actionCsn.params, (parameterCsn, parameterName) => {
          functionImport.append(new Edm.Parameter(v, { Name: parameterName }, parameterCsn, 'In' ));
        });

        if(Schema._ec)
          Schema._ec.append(functionImport);

        function getReturnType(action)
        {
          // it is safe to assume that either type or items.type are set
          let returns = action.returns.items || action.returns;
          let type = returns.type;
          if(type)
            type = edmUtils.mapCdsToEdmType(returns, messageFunctions, options.isV2());

          if(type && action.returns.items)
            type = `Collection(${type})`

          return type;
        }
      }

      /**
       * @param {object} parentCsn
       * @returns {[object[], boolean]} Returns a [ [ Edm Properties ], boolean hasStream ]:
       *                              array of Edm Properties
       *                              boolean hasStream : true if at least one element has @Core.MediaType assignment
       */
      function createProperties(parentCsn)
      {
        let props = [];
        let hasStream = false;
        edmUtils.forAll(parentCsn.elements, (elementCsn, elementName) =>
        {
          if(elementCsn._parent == undefined)
            setProp(elementCsn, '_parent', parentCsn);

          if(!elementCsn._ignore) {
            if(edmUtils.isAssociationOrComposition(elementCsn))
            {
              // Foreign keys are part of the generic elementCsn.elements property creation

              // This is the V4 edmx:NavigationProperty
              // gets rewritten for V2 in addAssociations()

              // suppress navprop creation only if @odata.navigable:false is not annotated.
              // (undefined !== false) still evaluates to true
              if (!elementCsn._target.abstract && elementCsn['@odata.navigable'] !== false)
              {
                let navProp = new Edm.NavigationProperty(v, {
                  Name: elementName,
                  Type: elementCsn._target.name
                }, elementCsn);

                props.push(navProp);
                // save the navProp in the global array for late constraint building
                navigationProperties.push(navProp);
              }
            }
            // render ordinary property if element is NOT ...
            // 1) ... annotated @cds.api.ignore
            // 2) ... annotated @odata.foreignKey4 and odataFormat: structured

            else if(isEdmPropertyRendered(elementCsn, options))
            {
              // CDXCORE-CDXCORE-173
              // V2: filter  @Core.MediaType
              if ( options.isV2() && elementCsn['@Core.MediaType']) {
                // CDXCORE-CDXCORE-177:
                // V2: don't render element but add attribute 'm:HasStream="true' to EntityType
                // V4: render property type 'Edm.Stream'
                hasStream = true;
                info(null, ['definitions', parentCsn.name],
                  `"${parentCsn.name}: Property "${elementName}" annotated with '@Core.MediaType' is removed from EDM in Odata V2`);

              } else
                props.push(new Edm.Property(v, { Name: elementName }, elementCsn));
            }
          }

        });
        return [ props, hasStream ];
      }

      function createComplexType(structuredTypeCsn)
      {
        // V4 attributes: Name, BaseType, Abstract, OpenType
        let attributes = { Name: structuredTypeCsn.name.replace(schemaNamePrefix, '') };

        let complexType = new Edm.ComplexType(v, attributes, structuredTypeCsn);
        let elementsCsn = structuredTypeCsn.items || structuredTypeCsn;
        let properties = createProperties(elementsCsn)[0];

        if(properties.length === 0) {
          warning(null, structuredTypeCsn.$path, `ComplexType "${structuredTypeCsn.name}" has no properties`);
        }
        complexType.append(...(properties));

        Schema.append(complexType);
      }

      // V4 <TypeDefintion>
      function createTypeDefinition(typeCsn)
      {
        // derived types are already resolved to base types
        let typeDef;
        let props = { Name: typeCsn.name.replace(schemaNamePrefix, '') };
        if((typeCsn.items && typeCsn.items.enum) || typeCsn.enum) {
          if (!builtins.isIntegerTypeName(typeCsn.type)) {
            warning(null, ['definitions', typeCsn.name], `Only integer enums are allowed in OData`);
          }
          typeDef = new Edm.EnumType(v, props, typeCsn);
        } else {
          typeDef = new Edm.TypeDefinition(v, props, typeCsn );
        }
        Schema.append(typeDef);
      }

      /*
      * addAssociation() constructs a V2 association.
      * In V4 all this has been simplified very much, the only thing actually left over is
      * <ReferentialConstriant> that is then a sub element to <NavigationProperty>.
      * However, referential constraints are substantially different to its V2 counterpart,
      * so it is better to reimplement proper V4 construction of<NavigationProperty> in a separate
      * function.
      *
      * This method does:
      * rewrite <NavigationProperty> attributes to be V2 compliant
      * add <Association> elements to the schema
      * add <End>, <ReferentialConstraint>, <Dependent> and <Principal> sub elements to <Association>
      * add <AssociationSet> to the EntityContainer for each <Association>
      */
      function addAssociation(navigationProperty)
      {
        let constraints = navigationProperty._csn._constraints;
        let parentName = navigationProperty._csn._parent.name.replace(schemaNamePrefix, '');
        let plainAssocName = parentName + NAVPROP_TRENNER + navigationProperty.Name.replace(VALUELIST_NAVPROP_PREFIX, '');
        let assocName = plainAssocName;
        let i = 1;
        while(NamesInSchemaXRef[assocName] !== undefined) {
          assocName = plainAssocName + '_' + i++;
        }

        let fromRole = parentName;
        let toRole = navigationProperty.Type.replace(schemaAliasPrefix, ''); // <= navprops type should be prefixed with alias

        let fromEntityType = fromRole;
        let toEntityType = toRole;

        // The entity set name may not be the same as the type name (parameterized entities have
        // differing set names (<T>Parameters => <T>, <T>Type => <T>Set)
        let fromEntitySet = ( navigationProperty._csn._parent.entitySetName || fromEntityType).replace(schemaNamePrefix, '');
        let toEntitySet = (navigationProperty._targetCsn.entitySetName || toEntityType).replace(schemaNamePrefix, '');

        // from and to roles must be distinguishable (in case of self association entity E { toE: association to E; ... })

        if(fromRole === toRole) {
          if(constraints._partnerCsn)
            fromRole += '1';
          else
            toRole += '1';
        }

        // add V2 attributes to navigationProperty
        navigationProperty.Relationship = fullQualified(assocName);
        navigationProperty.FromRole = fromRole;
        navigationProperty.ToRole = toRole;

        // remove V4 attributes
        if(navigationProperty.Type != undefined)
          delete navigationProperty.Type;
        if(navigationProperty.Partner != undefined)
          delete navigationProperty.Partner;
        if(navigationProperty.ContainsTarget != undefined)
          delete navigationProperty.ContainsTarget;

        /*
          If NavigationProperty is a backlink association (constraints._originAssocCsn is set), then there are two options:
          1) Counterpart NavigationProperty exists and is responsible to create the edm:Association element which needs to
            be reused by this backlink association. This is save because at this point of the processing all NavProps are created.
          2) Counterpart NavigationProperty does not exist (@odata.navigable:false), then the missing edm:Association element
            of the origin association needs to be created as if it would have been already available in case (1).
        */

        let reuseAssoc = false;
        let forwardAssocCsn = constraints._partnerCsn;
        if(forwardAssocCsn)
        {
          // This is a backlink, swap the roles and types, rewrite assocName
          [ fromRole, toRole ] = [ toRole, fromRole ];
          [ fromEntityType, toEntityType ] = [ toEntityType, fromEntityType ];
          [ fromEntitySet, toEntitySet ] = [ toEntitySet, fromEntitySet ];

          parentName = forwardAssocCsn._parent.name.replace(schemaNamePrefix, '');
          assocName = plainAssocName = parentName + NAVPROP_TRENNER + forwardAssocCsn.name.replace(VALUELIST_NAVPROP_PREFIX, '');
          i = 1;
          while(NamesInSchemaXRef[assocName] !== undefined && !(NamesInSchemaXRef[assocName][0] instanceof Edm.Association)) {
            assocName = plainAssocName + '_' + i++;
          }

          navigationProperty.Relationship = fullQualified(assocName)

          reuseAssoc = !!forwardAssocCsn._NavigationProperty;
          constraints = forwardAssocCsn._constraints;
          constraints._multiplicity = edmUtils.determineMultiplicity(forwardAssocCsn);
        }

        if(reuseAssoc)
        {
          // Example:
          // entity E { key id: Integer; toF: association to F; };
          // entity F { key id: Integer; toE: composition of E on toE.toF = $self; };
          //
          // Consider we're in NavigationProperty 'toE' which is the backlink to F.
          // Then forwardAssocCsn is 'E_toF' with two Ends: E, F.
          // Backlink F.toE is a composition, making E existentially dependant on F.
          // So End E of Association E_toF (which is End[0]) receives Edm.OnDelete.
          // Depending on the order of the navigation properties it might be that the
          // forward Edm.Association has not yet been produced. In this case Edm.OnDelete
          // is parked at the forward NavigationProperty.

          if(!forwardAssocCsn._NavigationProperty._edmAssociation && navigationProperty._csn.type === 'cds.Composition')
          {
            // TODO: to be specified via @sap.on.delete
            forwardAssocCsn._NavigationProperty.set( { _OnDeleteSrcEnd: new Edm.OnDelete(v, { Action: 'Cascade' }) } );
          }
          return;
        }

        // Create Association and AssociationSet if this is not a backlink association.
        // Store association at navigation property because in case the Ends must be modified
        // later by the partner (backlink) association
        navigationProperty._edmAssociation = new Edm.Association(v, { Name: assocName }, navigationProperty,
                                        [ fromRole, fullQualified(fromEntityType) ],
                                        [ toRole, fullQualified(toEntityType) ],
                                        constraints._multiplicity );
        if(NamesInSchemaXRef[assocName] === undefined) {
          NamesInSchemaXRef[assocName] = [ navigationProperty._edmAssociation ];
        }
        else {
          navigationProperty._edmAssociation.push(navigationProperty._edmAssociation);
        }
        // Add ReferentialConstraints if any
        if(!navigationProperty._isCollection && Object.keys(constraints.constraints).length > 0) {
          // A managed composition is treated as association
          if(navigationProperty._csn.type === 'cds.Composition' && (navigationProperty._csn.on || navigationProperty._csn.onCond)) {
            navigationProperty._edmAssociation.append(Edm.ReferentialConstraint.createV2(v,
              toRole, fromRole, constraints.constraints));
          }
          else {
            navigationProperty._edmAssociation.append(Edm.ReferentialConstraint.createV2(v,
              fromRole, toRole, constraints.constraints));
          }
        }

        Schema.append(navigationProperty._edmAssociation);
        if(Schema._ec && !navigationProperty._targetCsn.$proxy) {
          let assocSet =  new Edm.AssociationSet(v, { Name: assocName, Association: fullQualified(assocName) },
            fromRole, toRole, fromEntitySet, toEntitySet);
          if(navigationProperty._csn._SetAttributes)
            assocSet.setSapVocabularyAsAttributes(navigationProperty._csn._SetAttributes);
          Schema._ec.append(assocSet);
        }
      }

      // produce a full qualified name replacing the namespace with the alias (if provided)
      function fullQualified(name)
      {
        return schemaAliasPrefix + name.replace(schemaNamePrefix, '')
      }
    }

    function createAnnotations(edm)
    {
      /** @type {object} */
      let annoEdm = translate.csn2annotationEdm(csn, serviceCsn.name, options);
      for(let i = 0; i < annoEdm.getSchemaCount(); i++)
      {
        edm.setAnnotations(annoEdm.getAnnotations(i), i);
      }
      edm._defaultRefs.push(...annoEdm._defaultRefs);
    }
  }
}
module.exports = { csn2edm, csn2edmAll };
