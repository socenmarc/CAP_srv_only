const EventContext = require ('./Context')
const cds = require ('../index')

/**
 * Instances of class cds.Event represent asynchronous messages as well as
 * synchronous requests. The latter are instances of subclass cds.Request.
 */
class Event extends EventContext {

  set method(m) { if (m) super.method = m }
  get method() {
    return super.method = Crud2Http[this.event] || this.event
  }

  set event(e) { if (e) super.event = e }
  get event() {
    if (this._.method) return super.event = Http2Crud[this._.method] || this._.method
    if (this.query) return super.event = Query2Crud(this.query)
    return super.event = undefined
  }

  set entity(e) {
    if (e) super.entity = e.name ? (this.target = e).name : e
  }
  get entity() {
    return super.entity = this.target && this.target.name
  }

  set path(p) {
    if (p) this._.path = p.startsWith('/') ? p.slice(1) : p
  }
  get path() { // NOSONAR
    const {_} = this
    if (_.path) return super.path = _fqn ([_.path],0,this)
    const q = this.query
    if (q) {
      if (q.SELECT) return super.path = _fqn (q.SELECT,'from', this)
      if (q.INSERT) return super.path = _fqn (q.INSERT,'into', this)
      if (q.UPDATE) return super.path = _fqn (q.UPDATE,'entity', this)
      if (q.DELETE) return super.path = _fqn (q.DELETE,'from', this)
    }
    if (_.target) return super.path = _.target.name
    if (_.entity) return super.path = _.entity.name || _fqn (_,'entity',this)
    else return super.path = undefined
  }

  set target(t) { if (t) super.target = t }
  get target() {
    const {_} = this; if (_.entity && _.entity.name) return super.target = _.entity
    const m = this._model, defs = m && m.definitions || {}
    const p = this.path // IMPORTANT: We need to invoke this.path to ensure fqn-resolved names
    return super.target = typeof this.query === 'object' ? cds.infer(this.query, defs) : defs[p]
  }

  set data(d) { if(d) super.data = d } //> undefined data is frequently passed in via ._
  get data() {
    const q = this.query; if (!q) return super.data = undefined
    const { INSERT:I, UPDATE:U } = q
    if (I) return super.data = I.rows || I.values || I.entries && (I.entries.length > 1 ? I.entries : I.entries[0]) ||{}
    if (U) return super.data = U.data ||{}
    return super.data = {}
  }

  set headers(h) { if (h) super.headers = h }
  get headers() {
    return super.headers = this._.req && this._.req.headers || {}
  }

  // dummy implementation to allow instances in srv.dispatch
  reply(x) { return x }
}


const Crud2Http = {
  READ: 'GET',
  CREATE: 'POST',
  UPDATE: 'PATCH',
  UPSERT: 'PUT',
  DELETE: 'DELETE',
}

const Http2Crud = {
  POST: 'CREATE',
  GET: 'READ',
  PUT: 'UPDATE',
  PATCH: 'UPDATE',
  DELETE: 'DELETE',
}

const SQL2Crud = {
  SELECT: 'READ',
  INSERT: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  CREATE: 'CREATE ENTITY',
  DROP:   'DROP ENTITY',
}

const Query2Crud = (q) => {
  if (typeof q === 'string') return SQL2Crud[q.match(/^\s*(\w+)/)[1]]
  else for (let each in SQL2Crud) if (each in q) return SQL2Crud[each]
}

const _fqn = (x,p,req) => {
  const n = x[p]
  if (typeof n === 'object') {
    const {ref} = n; if (!ref) return '<unresolved path>'
    ref[0].id ? _fqn(ref[0],'id',req) : _fqn(ref,0,req)
    return ref.map(x=>x.id||x).join('/')
  }
  const srv = req._tx; if (srv) {
    if (!srv.model && srv.namespace && !n.startsWith(srv.namespace)) return x[p] = `${srv.namespace}.${n}`
    if (n in srv.entities) return x[p] = srv.entities[n].name
  }
  return n
}

Event.Context = EventContext
module.exports = exports = Event
