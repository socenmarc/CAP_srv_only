const resolveStructured = require('./resolveStructured')
const ensureNoDraftsSuffix = name => name.replace(/_drafts$/g, '')
const isStructured = element => element && element.elements

const _getEntityNames = from => {
  if (from.ref) {
    return [ensureNoDraftsSuffix(from.ref[0])]
  }

  if (from.SET) {
    return Array.from(
      from.SET.args.reduce((set, elem) => {
        for (const entityName of _getEntityNames(elem.SELECT.from)) {
          set.add(entityName)
        }
        return set
      }, new Set())
    )
  }

  if (Array.isArray(from.args)) {
    // TODO this only considers first level refs and not from sub selects
    return from.args.filter(arg => arg.ref).map(arg => ensureNoDraftsSuffix(arg.ref[0]))
  }

  return []
}

const _flattenStructuredInExpand = (column, { _target: expandedEntity }) => {
  const flattenedElements = []
  const toBeDeleted = []
  for (const expandElement of column.expand) {
    if (expandElement.expand) {
      _flattenStructuredInExpand(expandElement, _getNavigationIfStruct(expandedEntity, expandElement.ref))
      continue
    }

    const propertyName = expandElement.ref[expandElement.ref.length - 1]
    const element = expandedEntity.elements[expandElement.ref[0]] // TODO alias
    if (isStructured(element)) {
      toBeDeleted.push(propertyName)
      flattenedElements.push(
        ...resolveStructured(
          { structName: element.name, structProperties: expandElement.ref.slice(1) },
          element.elements
        )
      )
    }
  }

  _flattenStructuredOrderBy(column.orderBy, expandedEntity)
  column.where = _flattenStructuredWhereHaving(column.where, expandedEntity)

  column.expand = column.expand.filter(e => !toBeDeleted.includes(e.ref[e.ref.length - 1]))
  column.expand.push(...flattenedElements)
}

const _flattenStructuredOrderBy = (orderBy, csnEntity) => {
  if (orderBy) {
    for (const order of orderBy) {
      const element = order.ref && csnEntity.elements[order.ref[0]]
      if (isStructured(element)) {
        order.ref = _flattenSingleStructured(order, element.elements) // order can only be one element and not a complex type
      }
    }
  }
}

const _flattenSingleStructured = ({ ref }, subElements) => {
  return resolveStructured({ structName: ref[0], structProperties: ref.slice(1) }, subElements)[0].ref
}

const _getVal = (data, name) => {
  if (!data) return null

  if (typeof data !== 'object') return data

  if (name in data) {
    return data[name]
  }

  return null
}

const _filterForStructProperty = (structElement, structData, prefix = '') => {
  const filterArray = []

  for (const elementName in structElement.elements) {
    const element = structElement.elements[elementName]
    if (isStructured(element)) {
      filterArray.push(
        ..._filterForStructProperty(element, structData && structData[element.name], prefix + '_' + element.name)
      )
    } else {
      if (element.type === 'cds.Association' || element.type === 'cds.Composition') continue
      filterArray.push({ ref: [`${prefix}_${element.name}`] }, '=', { val: _getVal(structData, element.name) }, 'and')
    }
  }

  return filterArray
}

const _nestedStructElement = (ref, element, prefix = `${element.name}`) => {
  const nestedElement = element.elements[ref[0]]

  if (ref.length === 1) {
    return { prefix, nestedElement }
  }

  if (isStructured(nestedElement)) {
    return _nestedStructElement(ref.slice(1), nestedElement, `${prefix}_${nestedElement.name}`)
  }
}

const _transformStructToFlatWhereHaving = ({ ref }, val, resArray, structElement) => {
  const structData = JSON.parse(val)

  if (ref.length === 1) {
    resArray.push(..._filterForStructProperty(structElement, structData, structElement.name))
  } else {
    const { nestedElement, prefix } = _nestedStructElement(ref.slice(1), structElement)
    resArray.push(..._filterForStructProperty(nestedElement, structData, `${prefix}_${nestedElement.name}`))
  }

  if (resArray[resArray.length - 1] === 'and') {
    resArray.pop()
  }
}

const _flattenStructuredWhereHaving = (filterArray, csnEntity) => {
  if (filterArray) {
    const newFilterArray = []
    for (let i = 0; i < filterArray.length; i++) {
      const refElement = filterArray[i]
      const element = refElement.ref && csnEntity.elements[refElement.ref[0]]

      if (isStructured(element)) {
        const flattenedElements = resolveStructured(
          { structName: refElement.ref[0], structProperties: refElement.ref.slice(1) },
          element.elements
        )
        if (flattenedElements.length === 1) {
          newFilterArray.push(flattenedElements[0])
        } else {
          // transform complex structured to multiple single structured
          _transformStructToFlatWhereHaving(filterArray[i], filterArray[i + 2].val, newFilterArray, element)
          i += 2 // skip next two entries e.g. ('=', '{struct:{int:1}}')
        }
      } else {
        newFilterArray.push(refElement)
      }
    }
    return newFilterArray
  }
}

const _getNavigationIfStruct = (entity, ref) => {
  const element = entity.elements[ref[0]]

  if (!element) return

  if (element._target) return element

  if (ref.length > 1) {
    return _getNavigationIfStruct(element, ref.slice(1))
  }

  return element.elements[ref[0]]
}

const _flattenColumns = (SELECT, flattenedElements, toBeDeleted, csnEntity) => {
  for (const column of SELECT.columns) {
    if (!column.ref) continue

    // TODO aliases are not working right now
    const structName = column.ref[0]

    const element = csnEntity.elements[structName]
    if (element && column.expand) {
      _flattenStructuredInExpand(column, _getNavigationIfStruct(csnEntity, column.ref))
      continue
    }

    if (isStructured(element)) {
      toBeDeleted.push(structName) // works with aliases?
      flattenedElements.push(
        ...resolveStructured({ structName, structProperties: column.ref.slice(1) }, element.elements)
      )
    }
  }
}

const flattenStructuredSelect = (SELECT, model) => {
  const entityNames = _getEntityNames(SELECT.from) // TODO consider alias for custom CQNs?

  for (const entityName of entityNames) {
    const entity = model.definitions[entityName]

    if (Array.isArray(SELECT.columns) && SELECT.columns.length > 0) {
      const flattenedElements = []
      const toBeDeleted = []
      _flattenColumns(SELECT, flattenedElements, toBeDeleted, entity)
      SELECT.columns = SELECT.columns.filter(e => (e.ref && !toBeDeleted.includes(e.ref[0])) || e.func || e.expand) // TODO aliases?
      SELECT.columns.push(...flattenedElements)
    }
    if (SELECT.from.args) {
      for (const arg of SELECT.from.args) {
        if (arg.SELECT) {
          flattenStructuredSelect(arg.SELECT, model)
        }
      }
    }

    _flattenStructuredOrderBy(SELECT.orderBy, entity)
    SELECT.where = _flattenStructuredWhereHaving(SELECT.where, entity)
    SELECT.having = _flattenStructuredWhereHaving(SELECT.having, entity)
  }
}

module.exports = {
  flattenStructured: flattenStructuredSelect,
  getNavigationIfStruct: _getNavigationIfStruct
}
