const cache = new Map()

const _isNavigation = element => {
  return element.type === 'cds.Composition' || element.type === 'cds.Association'
}

const _addSubTemplate = (elementName, subTemplate, templateElements) => {
  if (subTemplate.elements.size > 0) {
    const t = templateElements.get(elementName)
    if (t) {
      t.template = subTemplate
    } else {
      const tEl = templateElements.get(elementName)
      if (tEl) tEl.template = subTemplate
      else templateElements.set(elementName, { template: subTemplate })
    }
  }
}

const _addToTemplateElements = (templateElements, elementName, obj) => {
  const tEl = templateElements.get(elementName)
  if (tEl) Object.assign(tEl, obj)
  else templateElements.set(elementName, obj)
}

const _addCacheToTemplateElements = (templateElements, elementName, cached) => {
  const tEl = templateElements.get(elementName)
  if (tEl) tEl.template = cached.template
  else templateElements.set(elementName, cached)
}

const _isStructured = element => element.elements

const _pick = (pick, element, target, parent, templateElements) => {
  if (!_isStructured(element)) {
    const _picked = pick(element, target, parent, templateElements)
    if (_picked) return { plain: _picked }
    return
  }
  const picked = { structured: {} }
  for (const elName of Object.keys(element.elements)) {
    const el = element.elements[elName]
    const _picked = _pick(pick, el, target, parent, templateElements)
    if (_picked) picked.structured[elName] = _picked
  }
  if (Object.keys(picked.structured).length === 0) return
  return picked
}
/**
 *
 * @param {CSN} model: Model
 * @param {String} targetName: Name of target entity which needs to be traversed
 * @param {*} param1.pick: Function to pick items. If it returns a truthy value, the item will be picked. The returned value is part of the template.
 * @param {*} param1.ignore: Function to ignore items. If it returns a truthy value, the item will be ignored.
 * @param {*} parent: The parent entity
 * @param {*} entityMap: Internal - do not use
 */

const _getTemplate = (model, targetName, { pick, ignore }, parent = null, entityMap = new Map()) => {
  const target = model.definitions[targetName]
  const templateElements = new Map()
  const template = { target, elements: templateElements }
  entityMap.set(targetName, { template })

  for (const elementName of Object.keys(target.elements)) {
    const element = target.elements[elementName]
    if (ignore && ignore(element, target, parent)) continue

    const picked = _pick(pick, element, target, parent, templateElements)
    if (picked) {
      _addToTemplateElements(templateElements, elementName, { picked })
    }

    if (_isNavigation(element)) {
      const cached = entityMap.get(element.target)
      if (cached) {
        _addCacheToTemplateElements(templateElements, elementName, cached)
      } else {
        const subTemplate = _getTemplate(model, element.target, { pick, ignore }, target, entityMap)
        _addSubTemplate(elementName, subTemplate, templateElements)
      }
    }
  }

  return template
}

module.exports = (usecase, service, target, ...args) => {
  const model = service.model // > get model first as it may be added to tx (cf. "_ensureModel")
  if (service._is_tx) service = Object.getPrototypeOf(service)

  let usecaseCache = cache.get(service)
  if (!usecaseCache) {
    usecaseCache = new Map()
    cache.set(usecase, usecaseCache)
  }

  let serviceCache = usecaseCache.get(service)
  if (!serviceCache) {
    serviceCache = new Map()
    cache.set(service, serviceCache)
  }

  let modelCache = serviceCache.get(model)
  if (!modelCache) {
    modelCache = new Map()
    serviceCache.set(model, modelCache)
  }

  let template = modelCache.get(target)
  if (!template) {
    template = _getTemplate(model, target.name, ...args)
    modelCache.set(target, template)
  }

  return template
}
