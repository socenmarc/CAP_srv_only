const { getFlatArray, processCQNs } = require('../utils/deep')
const { timestampToISO } = require('../data-conversion/timestamp')
const { hasCompositionDelete, createCascadeDeleteCQNs } = require('../../common/utils/composition/compositionTree')

const deleteFn = executeDeleteCQN => async (model, dbc, query, req) => {
  const ts = timestampToISO(req.timestamp)

  if (hasCompositionDelete(model && model.definitions, query)) {
    let cqns = createCascadeDeleteCQNs(model && model.definitions, query)

    // the delete chunks, i.e., how many deletes can be processed in parallel
    const chunks = []
    for (const each of cqns) chunks.push(each.length)

    cqns = getFlatArray(cqns)

    if (cqns.length === 0) return 0
    const results = await processCQNs(executeDeleteCQN, cqns, model, dbc, req.user.id, req.user.locale, ts, chunks)
    // return number of affected rows of "root cqn"
    return results[0]
  }

  return executeDeleteCQN(model, dbc, query, req.user.id, req.user.locale, ts)
}

module.exports = deleteFn
