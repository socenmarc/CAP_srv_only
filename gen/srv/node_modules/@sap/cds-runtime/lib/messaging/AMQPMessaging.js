const cds = global.cds || require('@sap/cds/lib')
const MessagingService = require('./service')
const ClientAmqp = require('@sap/xb-msg-amqp-v100').Client
const { topic, queueName } = require('./common-utils/naming-conventions')
const { connect, disconnect, queued } = require('./common-utils/connections')
const { sender } = require('./common-utils/client')
const _error = console.error

const DEBUG = cds.debug('messaging')

const _depcrecated = options => {
  const cred = options && options.credentials
  if (cred) {
    if (cred.prefix) throw new Error(`'prefix' is not supported anymore.`)
    if (cred.queue) throw new Error(`'queue' property moved from credentials section to top-level options.`)
    if (cred.queueConfig) throw new Error(`'queueConfig' is now merged with the 'queue' property.`)
  }
  if (options.queue && typeof options.queue !== 'object') {
    throw new Error(`'queue' must be an object with a 'name' property and additional configuration options.`)
  }
}

class AMQPMessaging extends MessagingService {
  async init () {
    _depcrecated(this.options)
    const { optionsClient, optionsApp } = this._options(this.options)
    if (this.options.queue) {
      const queueConfig = { ...this.options.queue }
      delete queueConfig.name
      if (Object.keys(queueConfig).length) this.queueConfig = queueConfig
    }
    this.optionsClient = optionsClient
    this.optionsApp = optionsApp
    this.subscriptions = {
      queue: null,
      topics: new Set()
    }
    this.sender = null
    this.listening = false
    this.ready = false
    this.token = null
    this.client = new ClientAmqp(optionsClient.amqp)
    this.pending = { operations: Promise.resolve() }
    await connect(this.client)

    cds.once('listening', () => {
      this.ready = true
      this.listen()
    })

    super.subscribe('on', '*', undefined, (req, next) => {
      if (req.inbound) return next()
      this.sender || (this.sender = sender(this.client, this.optionsApp))
      DEBUG && DEBUG('Emit', { topic: req.event })
      if (this.options.outbox) req.on('succeeded', () => this._emit(req, this.sender))
      else return this._emit(req, this.sender)
    })
    return super.init()
  }

  // inbound -> listen to channel (once)
  async subscribe (phase, event, path, handler) {
    const topic = event
    if (!this.subscriptions.queue) {
      const queue = queueName(this.options, this.optionsClient, this.optionsApp)
      this.subscriptions.queue = queue
      const token = await queued(this.pending, this._putQueue, queue, this.optionsClient, this.queueConfig)
      this.token = token
      this._queueCreated = true
    }
    if (!this.subscriptions.topics.has(topic)) {
      await queued(this.pending, this._addSubscription, this.subscriptions.queue, topic, this.optionsClient, this.token)
      this.subscriptions.topics.add(topic)
    }
    await this.listen()
    return super.subscribe(phase, event, path, handler)
  }

  async listen () {
    /*
     * REVISIT:
     * this listen function gets invoked by cds serve before queue was created.
     * in a previous version, this.subscriptions.queue was set after the queue was created, but this caused other issues.
     * -> add and check this._queueCreated instead (for now)
     */
    const queue = this.subscriptions.queue
    if (queue && !this.listening && this.ready && this._queueCreated) {
      this.listening = true
      this._addDataListener(this.client, queue, async (_event, _payload, { done, failed }) => {
        const data = _payload.data
        const headers = { ..._payload }
        delete headers.data
        try {
          await this.emit({ event: _event, data, headers, inbound: true })
          done()
        } catch (e) {
          failed()
          _error(e)
        }
      })
    }
  }

  disconnect () {
    return disconnect(this.client)
  }

  topic (event, service) {
    return topic(event, service, this.optionsClient)
  }
}

module.exports = AMQPMessaging
