const cds = global.cds || require('@sap/cds/lib')

const { SELECT } = cds.ql

const { getParent } = require('./compositionTree')
const { checkReferenceIntegrity } = require('../../util/assert')
const { processDeep, processDeepAsync } = require('../../util/dataProcessUtils')
const { ensureNoDraftsSuffix, ensureDraftsSuffix } = require('./draftUtils')
const generateUUID = require('../../../common/utils/uuid')
const { ASSERT_DEEP_TO_ONE_ASSOCIATION, assertError } = require('../../util/assert')

const { DRAFT_COLUMNS, DRAFT_COLUMNS_ADMIN } = require('../../../common/constants/draft')

const _isAssociation = element => {
  return (
    element.type === 'cds.Association' && (!element['@odata.contained'] || element.name === 'DraftAdministrativeData')
  )
}

const _isAssociationToOneManaged = element => {
  return _isAssociation(element) && element.is2one && !element.on
}

const _isComposition = element => {
  return (
    element.type === 'cds.Composition' ||
    (element.type === 'cds.Association' && element['@odata.contained'] && element.name !== 'DraftAdministrativeData')
  )
}

const _prefixDraftColumns = () => {
  return DRAFT_COLUMNS_ADMIN.map(col => {
    return { ref: ['DRAFT_DraftAdministrativeData', col] }
  })
}

const _getSelectDraftDataCqn = (entityName, where) => {
  return SELECT.from(ensureDraftsSuffix(entityName), _prefixDraftColumns())
    .join('DRAFT.DraftAdministrativeData')
    .on(`DraftAdministrativeData_DraftUUID = "DRAFT.DraftAdministrativeData"."DraftUUID"`)
    .where(where)
}

const _getWheres = (key, data) => {
  const wheres = []
  for (const d of data) {
    wheres.push({ [key.name]: d[key.name] })
  }
  return wheres
}

const allKeysAreProvided = req => {
  const data = req.data && (Array.isArray(req.data) ? req.data : [req.data])
  for (const key of Object.values(req.target.keys)) {
    if (key.type === 'cds.Association' || DRAFT_COLUMNS.includes(key.name)) {
      continue
    }
    for (const d of data) {
      if (d[key.name] === undefined) return false
    }
  }
  return true
}

const _addWhereToCqn = (wheres, target, cqn) => {
  if (wheres.length === 1) {
    const whereObj = wheres[0]
    for (const key in whereObj) {
      // check if we have structured elements
      if (target.elements[key].elements) {
        whereObj[key] = { val: JSON.stringify(whereObj[key]) }
      }
    }
    cqn.where(whereObj)
  } else {
    cqn.where({ or: wheres })
  }
}

const getSelectCQN = (req, columns) => {
  const cqn = SELECT.from(req.target)

  if (columns) {
    cqn.columns(...columns)
  }

  const data = req.data && (Array.isArray(req.data) ? req.data : [req.data])

  for (const key of Object.values(req.target.keys)) {
    if (key.type === 'cds.Association' || DRAFT_COLUMNS.includes(key.name)) {
      continue
    }

    const wheres = _getWheres(key, data)
    if (wheres.length) {
      _addWhereToCqn(wheres, req.target, cqn)
    }
  }

  if (req.target.query && req.target.query.SELECT && req.target.query.SELECT.orderBy) {
    cqn.SELECT.orderBy = req.target.query.SELECT.orderBy
  }

  return cqn
}

const validateDraft = (result, req) => {
  if (!result || !result[0]) {
    req.reject(404)
    return
  }

  if (result[0].CreatedByUser !== req.user.id || result[0].InProcessByUser !== req.user.id) {
    req.reject(403, 'DRAFT_LOCKED_BY_ANOTHER_USER')
  }
}

const _flattenManagedToOneAssociation = (managedAssocToOneElement, entity, row, property, csn, req) => {
  const targetEntity = managedAssocToOneElement._target
  for (const key in targetEntity.keys) {
    const el = targetEntity.keys[key]
    if (_isAssociationToOneManaged(el)) {
      _flattenManagedToOneAssociation(el, targetEntity, row[managedAssocToOneElement.name], key, csn, req)
      continue
    }

    if (row[managedAssocToOneElement.name] === null) {
      row[managedAssocToOneElement.name + '_' + key] = null
    } else {
      row[managedAssocToOneElement.name + '_' + key] = row[managedAssocToOneElement.name][key]
      delete row[managedAssocToOneElement.name][key]
    }
  }

  if (row[managedAssocToOneElement.name] === null || Object.keys(row[managedAssocToOneElement.name]).length === 0) {
    // if there are no non key values left, remove assoc object
    delete row[managedAssocToOneElement.name]
  } else {
    // if non keys are left, throw error
    for (const prop in row[managedAssocToOneElement.name]) {
      const err = assertError(ASSERT_DEEP_TO_ONE_ASSOCIATION, managedAssocToOneElement)
      err.target += `.${prop}` // add property name to target
      req.error(err)
    }
  }
}

const _flattenDeepToOneAssociations = (entity, data, csn, req) => {
  if (!Array.isArray(data)) {
    return _flattenDeepToOneAssociations(entity, [data], csn, req)
  }

  for (const row of data) {
    for (const property in row) {
      const element = entity.elements[property]
      if (!element) continue

      if (_isAssociationToOneManaged(element)) {
        _flattenManagedToOneAssociation(element, entity, row, property, csn, req)
      } else if (element.elements) {
        _flattenDeepToOneAssociations(element, [row[element.name]], csn, req)
      }
    }
  }
}

const flattenDeepToOneAssociations = (req, csn) => {
  if (!req.target) {
    return
  }

  if (req.event !== 'CREATE' && req.event !== 'UPDATE') {
    return
  }

  // REVISIT: adopt template mechanism?
  processDeep(
    (data, entity) => {
      _flattenDeepToOneAssociations(entity, data, csn, req)
    },
    req.data,
    req.target,
    false,
    true
  )
}

const checkIntegrityWrapper = (req, csn, run) => async (data, entity) => {
  const errors = await checkReferenceIntegrity(entity, data, req, csn, run)
  if (errors.length !== 0) {
    for (const err of errors) {
      req.error(err)
    }
  }
}

const _isUncheckableInsert = query => {
  return query.INSERT && (query.INSERT.rows || query.INSERT.values || query.INSERT.as)
}

// REVISIT: lower to db layer, where it's used
const checkIntegrityUtil = async (req, csn, run) => {
  if (!run) {
    return
  }

  // REVISIT
  if (typeof req.query === 'string' || req.target._unresolved) {
    return
  }

  // FIXME: doesn't work for uncheckable inserts
  if (_isUncheckableInsert(req.query)) {
    return
  }

  // REVISIT: integrity check needs context.data
  if (Object.keys(req.data).length === 0) {
    // REVISIT: We may need to double-check re req.data being undefined or empty
    if (req.context && req.context.data && Object.keys(req.context.data).length > 0) {
      req.data = req.context.data
    } else if (req.query.DELETE) {
      req.data = req._beforeDeleteData
    }
  }
  if (Object.keys(req.data).length === 0) {
    return
  }

  await processDeepAsync(checkIntegrityWrapper(req, csn, run), req.data, req.target, false, true)
}

const _addDraftDataToContext = (req, result) => {
  validateDraft(result, req)

  if (req.rejected) {
    return
  }

  if (!req._draftMetadata) {
    req._draftMetadata = {}
  }

  DRAFT_COLUMNS_ADMIN.forEach(column => {
    if (column in result[0]) req._draftMetadata[column] = result[0][column]
  })

  req.data.DraftAdministrativeData_DraftUUID = result[0].DraftUUID
}

const addDraftDataFromExistingDraft = async (req, service) => {
  const parent = getParent(service, req)
  let result

  if (parent && parent.IsActiveEntity === 'false') {
    const parentWhere = [{ ref: [parent.keyName] }, '=', { val: parent.keyValue }]
    result = await req.run(_getSelectDraftDataCqn(parent.entityName, parentWhere))
    _addDraftDataToContext(req, result)
    return result
  }

  if (!parent) {
    const keys = Object.keys(req.target.keys)
    const rootWhere = keys.reduce((res, key) => {
      if (key === 'IsActiveEntity') {
        return res
      }
      res[key] = req.data[key]
      return res
    }, {})

    result = await req.run(_getSelectDraftDataCqn(ensureNoDraftsSuffix(req.target.name), rootWhere))
    if (result && result.length > 0) {
      _addDraftDataToContext(req, result)
    }
    return result
  }

  return []
}

const addGeneratedDraftUUID = async req => {
  req._draftMetadata = req._draftMetadata || {}
  req.data.DraftAdministrativeData_DraftUUID = generateUUID()
  req._draftMetadata.DraftUUID = req.data.DraftAdministrativeData_DraftUUID
}

const _updateNavigationApprovals = (restrictedProperty, navigationApprovals) => {
  if (restrictedProperty.InsertRestrictions && restrictedProperty.InsertRestrictions.Insertable === true) {
    navigationApprovals.Insertable = true
  }
  if (restrictedProperty.UpdateRestrictions && restrictedProperty.UpdateRestrictions.Updatable === true) {
    navigationApprovals.Updatable = true
  }
  if (restrictedProperty.DeleteRestrictions && restrictedProperty.DeleteRestrictions.Deletable === true) {
    navigationApprovals.Deletable = true
  }
}

const _getNavigationApprovals = (target, serviceEntities) => {
  const navigationApprovals = {}

  for (const serviceEntity of serviceEntities) {
    if (serviceEntity['@Capabilities.NavigationRestrictions.RestrictedProperties']) {
      for (const restrictedProperty of serviceEntity['@Capabilities.NavigationRestrictions.RestrictedProperties']) {
        if (serviceEntity.elements[restrictedProperty.NavigationProperty['=']].target === target.name) {
          _updateNavigationApprovals(restrictedProperty, navigationApprovals)
        }
      }
    }
  }
  return navigationApprovals
}

const getScenario = (entity, serviceEntities) => {
  if (entity['@readonly']) {
    return '@readonly'
  }

  if (entity['@insertonly']) {
    return '@insertonly'
  }

  let navApprovals = _getNavigationApprovals(entity, serviceEntities)

  let scenario = 'Not'
  if (entity['@Capabilities.InsertRestrictions.Insertable'] === false && !navApprovals.Insertable) {
    scenario += 'Insertable'
  }

  if (entity['@Capabilities.UpdateRestrictions.Updatable'] === false && !navApprovals.Updatable) {
    scenario += 'Updatable'
  }

  if (entity['@Capabilities.DeleteRestrictions.Deletable'] === false && !navApprovals.Deletable) {
    scenario += 'Deletable'
  }

  if (scenario.length > 3) {
    return scenario
  }
  return 'default'
}

/*
 * merge CQNs
 */
const _mergeExpandCQNs = (cqn, cqns) => {
  for (const c of cqns) {
    const cols = c.SELECT.columns.filter(col => col.expand)
    for (const col of cols) {
      if (!cqn.SELECT.columns.find(ele => ele.ref[0] === col.ref[0])) {
        cqn.SELECT.columns.push(col)
      }
    }
  }
}

/*
 * build and merge CQNs for (to many) compositions with input data
 */
const _getExpandCqnForInstance = (elementKey, data, req, definitions) => {
  let cqn

  const target = definitions[req.target.elements[elementKey].target]
  let compData = data[elementKey]
  if (target && compData) {
    if (!Array.isArray(compData)) {
      compData = [compData]
    }

    const cqns = []
    for (const data of compData) {
      cqns.push(getDeepSelect({ target, data }, definitions))
    }
    cqn = cqns[0]
    cqns.length > 0 && _mergeExpandCQNs(cqn, cqns)
  }

  return cqn
}

/*
 * build and merge CQNs for (batch) input data
 */
const _getExpandCqnForEntity = (elementKey, req, definitions) => {
  let cqn

  const data = Array.isArray(req.data) ? req.data : [req.data]

  let cqns = []
  for (const d of data) {
    cqns.push(_getExpandCqnForInstance(elementKey, d, req, definitions))
  }
  cqns = cqns.filter(cqn => cqn !== undefined)

  cqn = cqns[0]
  cqns.length > 0 && _mergeExpandCQNs(cqn, cqns)

  return cqn
}

const _columnsNoSkippedNoAssocNoDraft = elements =>
  Object.keys(elements).filter(
    k =>
      !DRAFT_COLUMNS.includes(k) &&
      !_isAssociation(elements[k]) &&
      !(elements[k]._target && elements[k]._target['@cds.persistence.skip'] === true)
  )

const _columnsAssocToOne = elements => Object.keys(elements).filter(k => _isAssociation(elements[k]))
const _addKeysRef = elements => {
  const keys = []
  for (const k of elements) {
    keys.push({ ref: [k.ref[0]] })
  }
  return keys
}

const _mergeAssocToOneColumns = (colsAssocToOne, req, cqn) => {
  if (colsAssocToOne.length !== 0) {
    for (const assocCol of colsAssocToOne) {
      const assocKeys = req.target.elements[assocCol].keys
      if (assocKeys) {
        const assocC = {
          ref: [assocCol],
          expand: _addKeysRef(assocKeys)
        }
        cqn.SELECT.columns = cqn.SELECT.columns ? cqn.SELECT.columns.concat(assocC) : [assocC]
      }
    }
  }
}

/*
 * recursively builds a select cqn for deep read after write
 * (depth determined by req.data)
 */
const getDeepSelect = (req, definitions) => {
  let cqn
  const cols = _columnsNoSkippedNoAssocNoDraft(req.target.elements)

  // root? -> with where clause
  if (req.event) {
    if (!allKeysAreProvided(req)) throw new Error('Not all keys provided')
    cqn = getSelectCQN(req, cols)
  } else {
    cqn = SELECT.from(req.target).columns(...cols)
  }
  const colsAssocToOne = _columnsAssocToOne(req.target.elements)
  _mergeAssocToOneColumns(colsAssocToOne, req, cqn)

  const comps = cols.filter(k => _isComposition(req.target.elements[k]))
  if (comps.length > 0) {
    for (const k of comps) {
      const expandCqn = _getExpandCqnForEntity(k, req, definitions)

      // transform cqn to expand OR remove composition column if no data in input
      const colIndex = cqn.SELECT.columns.findIndex(col => col.ref && Array.isArray(col.ref) && col.ref[0] === k)
      if (expandCqn && expandCqn.SELECT && expandCqn.SELECT.columns) {
        cqn.SELECT.columns[colIndex].expand = expandCqn.SELECT.columns
      } else {
        cqn.SELECT.columns.splice(colIndex, 1)
      }
    }
  }

  return cqn
}

module.exports = {
  addDraftDataFromExistingDraft,
  addGeneratedDraftUUID,
  getDeepSelect,
  allKeysAreProvided,
  getSelectCQN,
  getScenario,
  checkIntegrityUtil,
  flattenDeepToOneAssociations
}
