const cds = global.cds || require('@sap/cds/lib')

const { isDraftEnabled } = require('../../../../common/utils/draft')
const { isCustomOperation } = require('./request')
const expandToCQN = require('../odata-to-cqn/expandToCQN')
const QueryOptions = require('../okra/odata-server').QueryOptions
const { COMPLEX_PROPERTY } = require('../okra/odata-server').uri.UriResource.ResourceKind

const getTemplate = require('../../../../common/utils/template')

const _selectForFunction = (selectColumns, result, context) => {
  if (!Array.isArray(result)) result = [result]

  const keys = context._.returnType.keys

  for (const row of result) {
    for (const entry in row) {
      if (keys[entry]) {
        continue
      }

      if (!selectColumns.includes(entry)) {
        delete row[entry]
      }
    }
  }
}
const { ensureDraftsSuffix, isDraftActivateAction } = require('../../../services/utils/draftUtils')

const _expand = (model, uriInfo) => {
  const expand = uriInfo.getQueryOption(QueryOptions.EXPAND)

  if (!expand || expand.length === 0) {
    return []
  }

  return expandToCQN(model, expand, uriInfo.getFinalEdmType())
}

const _expandForFunction = async (uriInfo, result, req, srv) => {
  const results = Array.isArray(result) ? result : [result]

  // REVISIT: isDraft is (always?!) undefined because context._.returnType is not a string (at least always)
  const isDraft = isDraftEnabled(srv.model.definitions[req._.returnType])

  const isDraftActivate = isDraftActivateAction(req)

  // REVISIT: what happens here exactly?
  for (const row of results) {
    const selectQuery = req.statements.SELECT.from(
      isDraft && !isDraftActivate ? ensureDraftsSuffix(req._.returnType.name) : req._.returnType
    )

    for (const key in req._.returnType.keys) {
      if ((!isDraft || isDraftActivate) && key === 'IsActiveEntity') {
        continue
      }
      selectQuery.where(key, '=', row[key])
    }

    const expandCqn = _expand(srv.model, uriInfo)
    selectQuery.columns(expandCqn)

    const res = await cds.tx(req).run(selectQuery)
    if (res) Object.assign(row, res[0])
  }
}

const _cleanupResult = (result, context) => {
  if (!Array.isArray(result)) result = [result]

  for (const row of result) {
    for (const element in context._.returnType.elements) {
      if (context._.returnType.elements[element].is2many) {
        delete row[element]
      }
    }
  }
}

const getActionOrFunctionReturnType = (pathSegments, definitions) => {
  if (!isCustomOperation(pathSegments, true)) {
    return undefined
  }

  const actionOrFunction =
    pathSegments[pathSegments.length - 1].getFunction() || pathSegments[pathSegments.length - 1].getAction()
  if (actionOrFunction) {
    const returnType = actionOrFunction.getReturnType()
    if (returnType) {
      // eslint-disable-next-line standard/computed-property-even-spacing
      return definitions[
        returnType
          .getType()
          .getFullQualifiedName()
          .toString()
      ]
    }
  }
}

const actionAndFunctionQueries = async (req, odataReq, result, srv) => {
  _cleanupResult(result, req)

  if (odataReq.getQueryOptions().$select) {
    _selectForFunction(odataReq.getQueryOptions().$select.split(','), result, req)
  }
  // REVISIT: we need to read direcly from db for this, which might not be there!
  if (odataReq.getQueryOptions().$expand && cds.db) {
    await _expandForFunction(odataReq.getUriInfo(), result, req, srv)
  }
}

const _getBacklinkName = element => {
  if (element.on && element.on.length === 3 && element.on[0].ref && element.on[2].ref) {
    if (element.on[0].ref[0] === '$self') {
      return element.on[2].ref[element.on[2].ref.length - 1]
    } else if (element.on[2].ref[0] === '$self') {
      return element.on[0].ref[element.on[0].ref.length - 1]
    }
  }
}

const _isContainment = element => {
  // REVISIT: cds.env.effective will be there with @sap/cds^4.2
  const effective = cds.env.effective || cds.env
  return (
    ((element.type === 'cds.Association' && element['@odata.contained']) ||
      (element.type === 'cds.Composition' && effective.odata.containment)) &&
    element.name !== 'DraftAdministrativeData_DraftUUID'
  )
}

const _isBacklink = (element, parent) => {
  if (element.type !== 'cds.Association') {
    return false
  }

  if (!parent || !element.keys) {
    return false
  }

  if (element.target !== parent.name) {
    return false
  }

  for (const parentElement of Object.values(parent.elements)) {
    if (_isContainment(parentElement) && _getBacklinkName(parentElement) === element.name) {
      return true
    }
  }

  return false
}

const _removeKeys = (row, template) => {
  for (const [tKey, tValue] of template.elements) {
    const { template: subTemplate } = tValue
    const val = row[tKey]

    // process complex
    if (subTemplate) {
      if (Array.isArray(val)) {
        for (const subVal of val) {
          _removeKeys(subVal, subTemplate)
        }
      } else if (val) {
        _removeKeys(val, subTemplate)
      }
      continue
    }

    // remove element from result
    delete row[tKey]
  }
}

const _getParent = (model, name) => {
  const assoc = Object.values(model.definitions[name].elements).find(
    element => element.type === 'cds.Association' && _isBacklink(element, element._target)
  )
  if (assoc) return assoc._target
  return null
}

const _pick = (element, _, parent, templateElements) => {
  if ((element.type !== 'cds.Association' && element.type !== 'cds.Composition') || !element.keys) {
    return
  }

  // FIXME: no $generatedFieldName (cf. https://github.wdf.sap.corp/cdx/cds-runtime/pull/464)
  if (_isContainment(element) || _isBacklink(element, parent)) {
    element.keys
      .map(key => key['$generatedFieldName'])
      .filter(key => key !== undefined)
      .forEach(key => templateElements.set(key, true))
  }
}

const removeContainmentKeys = (service, target, result, backlinks = []) => {
  const model = service.model

  // TODO: workaround for draft
  if (!model.definitions[target.name] || !result) {
    return
  }

  const template = getTemplate('odata-containment', service, target, { pick: _pick }, _getParent(model, target.name))

  if (template.elements.size === 0) return

  const data = Array.isArray(result) ? result : [result]

  for (const row of data) {
    _removeKeys(row, template)
  }
}

const resolveStructuredName = (pathSegments, index, nameArr = []) => {
  if (pathSegments[index].getKind() === COMPLEX_PROPERTY) {
    const prop = pathSegments[index].getProperty()
    nameArr.unshift(prop.getName())
    return resolveStructuredName(pathSegments, --index, nameArr)
  }
  return nameArr
}

module.exports = {
  _expand,
  resolveStructuredName,
  actionAndFunctionQueries,
  getActionOrFunctionReturnType,
  removeContainmentKeys
}
