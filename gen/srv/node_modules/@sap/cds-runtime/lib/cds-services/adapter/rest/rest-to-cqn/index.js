const cds = global.cds || require('@sap/cds/lib')

// REVISIT: should be cds.ql
const { INSERT, SELECT, UPDATE, DELETE } = require('../../../statements')

const { createCqlString } = require('./utils')
const getColumns = require('../../../services/utils/columns')
const { LIMIT } = require('../../../../common/constants/limit')

const MAX = (cds.env.query && cds.env.query.limit && cds.env.query.limit.max) || LIMIT.PAGE.MAX

const _getPaging = ({ query: { $top, $skip } }) => {
  return [Number($top) || MAX, Number($skip) || 0]
}

const _readToCQN = ({ isCollection, segments }, target, restReq) => {
  const key = Object.keys(target.keys)[0]
  const cqn = SELECT.from(createCqlString(target, key, segments[1]), getColumns(target, true, true))

  if (isCollection) {
    cqn.limit(..._getPaging(restReq))
  }

  return cqn
}

/**
 * @param {Object} parsed
 * @param {Object} data
 * @param {Object} restReq
 * @returns {Object}
 */
module.exports = (parsed, data, restReq) => {
  const { event, segments, target } = parsed

  const key = target && Object.keys(target.keys)[0]
  const value = segments && segments.length > 1 && segments[1]

  switch (event) {
    case 'CREATE':
      return Array.isArray(data) ? data.map(d => INSERT.into(target).entries(d)) : [INSERT.into(target).entries(data)]
    case 'READ':
      return _readToCQN(parsed, target, restReq)
    case 'UPDATE':
      return UPDATE(createCqlString(target, key, value)).data(data)
    case 'DELETE':
      return DELETE.from(createCqlString(target, key, value))
    default:
      return target ? SELECT.from(createCqlString(target, key, value)) : undefined
  }
}
