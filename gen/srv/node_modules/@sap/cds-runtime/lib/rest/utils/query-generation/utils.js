// needs to be more sophisticated, e. g. odata v2/v4 and resolving "author/id"
const formatVal = (val, element, target) => {
  const csnElement = target.elements[element]
  switch (csnElement.type) {
    case 'cds.String':
      return `'${val}'`
    case 'cds.DateTime':
    case 'cds.Date':
    case 'cds.Timestamp':
      return process.env.T19 ? `'${val}'` : val // TODO: improve
    default:
      return val
  }
}

// only supported structure is ref, =, val
const _isValidWhereConditionRest = where => {
  return where.length === 3 && where[0].ref && where[1] === '=' && 'val' in where[2]
}

const _generateRestKeyPath = where => {
  if (!_isValidWhereConditionRest(where)) {
    throw new Error("Feature not supported: complex where of fluent API (not in format 'a = 1')")
  }

  return where[2].val
}

const _isValidWhereConditionOdata = where => {
  for (let i = 0; i < where.length; i++) {
    if ((i === 0 || where[i - 1] === 'and') && where[i].ref) continue
    if (where[i - 1].ref && where[i] === '=') continue
    if (where[i - 1] === '=' && 'val' in where[i]) continue
    if ('val' in where[i - 1] && where[i] === 'and') continue
    return false
  }

  return true
}

// only supported structure is alternating ref, =, val combined with and
const _generateOdataKeyPath = (where, target) => {
  // remove brackets
  const whereNoBrackets = where.filter(e => e !== '(' && e !== ')')

  if (!_isValidWhereConditionOdata(whereNoBrackets)) {
    throw new Error("Feature not supported: complex where of fluent API (not in format 'a = 1')")
  }

  const keyPath = where.map((e, i) => {
    if (e.ref) return e.ref[e.ref.length - 1]
    if (e === '=') return e
    if ('val' in e) {
      const previousRef = where[i - 2].ref
      return formatVal(e.val, previousRef[previousRef.length - 1], target)
    }
    if (e === 'and') return ','
  })

  return `(${keyPath.join('')})`
}

const generateKeysOfWhere = (where, type, target) => {
  if (type === 'rest') return _generateRestKeyPath(where)
  // odata v2 and v4
  return _generateOdataKeyPath(where, target)
}

const splitByAndGetValueByIndex = (value, split = '.', offset = 0) => {
  const parts = value.split(split)
  return parts[parts.length - 1 - offset]
}

const generateKeyPath = (from, type, transitions) => {
  if (typeof from === 'string') return { path: from }
  return {
    path: from.ref
      .map((f, i) => {
        if (f.id) {
          let keyPath = generateKeysOfWhere(f.where, type, transitions[i].target)
          if (type === 'rest') keyPath = `/${keyPath}`
          return `${f.id}${keyPath}`
        }
        return f
      })
      .join('/')
  }
}

module.exports = {
  formatVal,
  generateKeyPath,
  generateKeysOfWhere,
  splitByAndGetValueByIndex
}
